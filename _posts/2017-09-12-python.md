---
layout: post
title: Python 정리정돈
tags:
  - 개발공부
description: |
  Python 문법 정리입니다.
author: Yamoong
---

# Python

## 1. pyenv, virtualenv, iPython 설치 및 설정

### pyenv

pyenv는 프로젝트별로 파이썬 버전을 관리할 수 있도록 도와주는 라이브러리이다. 여러 프로젝트를 동시에 진행하다보면, 프로젝트마다 사용하는 버전이 달라질 수 있다. 이러한 파이썬 버전간의 충돌을 방지하기 위해 사용한다.

### virtualenv

파이썬 개발환경을 프로젝트별로 분리해서 관리할 수 있게 해주는 라이브러리이다. 위의 pyenv와 다른 점은, pyenv는 파이썬의 버전을 관리해주는 것이며, virtualenv는 파이썬 패키지 설치 환경을 따로 관리하는 가상 환경이다.

### pyenv-virtualenv

### pyenv 설치

`curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash`

### pyenv 가상환경 생성

`pyenv viertualenv <version> <env_name>`

> `pyenv virtualenv 3.6.2 fc-python` 입력

사용할 폴더로 이동   

해당 폴더에서 가상환경 지정

`pyenv local fc-python`

가상환경 지우기

`pyenv uninstall <env_name>`

```
각종 용어

리터럴
변하지 않은 고정된 데이터 자체의 표현

- 5 (정수형 데이터)
- "Fastcampus" (문자열 데이터)
- 1.4937 (부동소수점 데이터)

표현식(expression)
값을 의미하는 표현 또는 값을 반환하는 표현

'''Python
>>> sec = 60
>>> 365*24*sec - 표현식
5256600        - 정수 525600의 리터럴 값
'''

구문(statement)
값의 의미를 지니지 않으며, 어떠한 목적을 수행하는 코드

'''Python
>>> for char in '안녕하세요':  - 구문(제어문)
...   print(char)
...
안
녕
하
세
요
```

## 2\. 변수

파이썬은 모든 것이 객체로 이루어져 있다. 객체는 데이터의 형태를 결정해주는 타입으로, 파이썬에서는 객체의 타입을 바꿀 수 없다.

프로그래머는 변수를 선언하고 사용하는 형태로 컴퓨터의 메모리에 값을 항당하고, 참조할 수 있다. 파이썬에서는 값을 할당할 때 `=` 기호를 사용한다.

> 일반적으로, 프로그래밍 언어에서 같다(Equal)의 의미는 =가 아닌 ==이 담당한다.

```
var1 =100
var2 =var1
var3 =var1

id(var1)
9288864
id(var2)
9288864
id(var3)
9288864

var1=101 할당 이후

var2와 var3는 여전히 100의 주소를 가리키고 있음을 알 수 있음.
```

변수는 단지 이름일 뿐이며, 그 자체가 어떠한 값을 갖는 것이 아니다. 변수는 단순히 해당 객체를 **참조** 하는 역할을 한다.

- 변수의 타입 확인

내장함수 _Type_ 사용

`<class 'int'>` , `<class 'str'>`

위의 출력에서 클래스는 객체의 타입(정의)를 나타낸다.

- 변수의 이름 제한

사용가능한 문자 소문자 대문자 숫자 `언더스코어(_)`

이름은 숫자로 시작할 수 없으며, 언더스코어로 시작하는 변수명은 특별한 처리방법을 따르므로 일반적으로 사용하지 않는다.

- 예약어

```
False, class, finally, is, return,
None, continue, for, lambda, try,
True, def, from, nonlocal, while,
and, del, global, not, with,
as, elif, if, or, yield,
assert, else, import, pass,
break, except, in, raise
```

- 변수의 입력과 출력

입력은 내장함수 **input** 사용

```
>>> var = input()
```

입력받는 프롬프트를 띄우려고 할 경우, `input`에 문자열을 인자로 전달해준다.

```
>>> var = input('숫자를 입력해주세요 : ')
```

출력은 내장함수 **print** 사용

```
>>> print(var)
```

## 3, 내장데이터 타입(숫자)

- 수학 연산자

연산자 | 설명    | 예      | 결과
--- | ----- | ------ | ----
+   | 더하기   | 32 + 7 | 39
-   | 빼기    | 82 - 2 | 80
*   | 곱하기   | 3 * 7  | 21
/   | 나누기   | 7 / 2  | 3.5
//  | 정수나누기 | 7 // 2 | 3
%   | 나머지   | 7 % 3  | 1
**  | 지수    | 2**10  | 1024

- 산술 연산자 결합

a에 100을 할당하고, 3을 뺀 결과를 다시 a에 할당한다.

```
>>> a = 100
>>> result = a - 3
>>> a = result
>>> print(a)
97
```

위 코드는 아래와 같이 줄여서 사용가능하다.

```
>>> a = 100
>>> a = a - 3
>>> print(a)
97
```

위 코드는 산술 연산자 결합으로 아래와 같이 사용가능하다.

```
>>> a = 100
>>> a -= 3
>>> print(a)
97
```

- 우선순위

우선순위 규칙이 적용되지만, 가독성에 문제가 있을 경우 괄호로 묶어준다.

- 진수(base)

기본적으로 숫자형 데이터는 10진수로 간주되지만, 파이썬에서는 2진수, 8진수, 16진수를 표현할 수 있다.

- 2진수(binary): **0b** 또는 **0B** 로 시작
- 8진수(octal): **0o** 또는 **0O** 로 시작
- 16진수(hex): **0x** 또는 **0X** 로 시작 - 0123456789abcdef

## 5.4\. 문자열

> 파썬3에서는 문자열에서 기본적으로 유니코드(Unicode)를 사용하며, 불변(immutable)하다.

- 문자열 표현

**작은 따옴표 또는 큰 따옴표**

```
>>> '패스트캠퍼스'
'패스트캠퍼스'
>>> "패스트캠퍼스"
'패스트캠퍼스'
```

작은 따옴표 또는 큰 따옴표를 사용했을 때, 사용하지 않은 인용 부호는 문자열 내부에서 사용 가능하다.

```
>>> '패스트캠퍼스 "웹 프로그래밍 스쿨"'
'패스트캠퍼스 "웹 프로그래밍 스쿨"'
```

**세 개의 작은 따옴표 또는 큰 따옴표** 여러줄에 걸친 문자열을 나타낼 때 사용

```
>>> '''소환사 여러분.
... 7.1 패치를 소개합니다.'''
```

- 문자열 더하기

```
>>> notice = ''
>>> notice += '공지사항'
```

- 형변환

내장함수 **str** 을 사용

```
>>> str(147)
'147'
```

문자열을 제외한 객체를 'print' 함수로 호출하면, 내부적으로 'str'함수를 사용한 결과를 나타내준다.

- 스케이프 문자

특수문자, 또는 특별한 역할을 하는 의미를 나타내는 문자를 뜻한다.

이스케이프 문자 | 설명
-------- | -----------
\a       | 비프음 발생
\t       | 탭(tab)
\n       | 줄바꿈
\        | \(역슬래시) 입력
\'       | 작은따옴표(') 입력
\"       | 큰따옴표(") 입력

- 인덱스 연산

문자열에서 문자를 추출하기 위해 대괄호와 오프셋을 지정할 수 있다. 가장 왼쪽은 0이며, 가장 오른쪽은 -1로 시작한다.

```
>>> lux = '빛으로 강타해요!'
>>> lux[0]
'빛'
>>> lux[-1]  - 가장 마지막 인덱스 -1 부터 거꾸로
'!'
>>> lux[50]  - 인덱스 숫자를 초과해 입력하면 오류
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
```

문자열은 불변이므로 인덱싱한 부분에 새 값을 대입할 수 없다.

```
>>> lux[0] = '손'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
```

- 슬라이스 연산

**[start:end:step]** 형식을 사용한다.

- [\:]

  - 처음부터 끝까지

- [start\:]

  - start오프셋부터 마지막까지

- [:end]

  - 처음부터 end오프셋까지

- [start:end]

  - start오프셋부터 end오프셋까지

- [6.art\:end\:step]

  - start오프셋부터 end오프셋까지, step만큼씩 뛰어넘은 부분

- 길이

내장함수 **len** 을 사용

- 문자열 나누기(split)

문자열의 내장함수 **split** 을 사용

**split** 함수에 인자로 주어진 **구분자** 를 기준으로 하나의 문자열을 리스트 형태로 반환해준다.

```python
>>> girlsday = "민아,유라,소진,혜리"
>>> girlsday.split(',')
['민아,' '유라', '소진', '혜리']
```

**split** 함수에 인자를 주지 않을 경우, 공백문자를 구분자로 사용한다.

- 문자열 결합(join)

**split** 함수와 반대의 역할을 한다. 문자열 리스트를 하나의 문자열로 결합해주며, 각 문자열을 결합해줄 구분자 문자열을 지정한 후 **join** 함수를 사용해준다.

```python
>>> girlsday_list = girlsday.split(',')
>>> girlsday_str = ', '.join(girlsday_list)
>>> print(girlsday_str)
민아, 유라, 소진, 혜리
```

- 대소문자 다루기

```python
>>> lux = 'lux, the Lady of Luminosity'
>>> lux.capitalize() - 첫 글자를 대문자로
'Lux, the lady of luminosity'
>>> lux.title() - 각 단어의 첫 글자를 대문자로
'Lux, The Lady Of Luminosity'
>>> lux.upper() - 모든 글자를 대문자로
'LUX, THE LADY OF LUMINOSITY'
>>> lux.lower() - 모든 글자를 소문자로
'lux, the lady of luminosity'
>>> lux.swapcase() - 대문자는 소문자로, 소문자는 대문자로
'LUX, THE lADY OF lUMINOSITY'
```

- 공식문서

[Text Sequence - String Methods](https://docs.python.org/3/library/stdtypes.html#string-methods)

## 5\. 문자열 포맷

### 옛 스타일(%)

```
string % data
```

변환타입 | 설명
---- | ----------------------------
%s   | 문자열
%d   | 10진수
%x   | 16진수
%o   | 8진수
%f   | 10진 부동소수점수
%e   | 지수로 나타낸 부동소수점수
%g   | 10진 부동소수점수 혹은 지수로 나타낸 부동소수점수
%%   | 리터럴 %

```python
>>> '%s' % 42
'42'
>>> '%d x %d : %d' % (3, 4, 12)
'3 x 4 : 12'
```

- 정렬

```
%[정렬기준(-,없음)[전체글자수].[문자길이 또는 소수점 이후 문자길이][변환타입]]
```

```python
>>> d = 37
>>> f = 3.14
>>> s = 'Fastcampus'
>>> '%d %f %s' % (d, f, s)
'37 3.140000 Fastcampus'
>>> '%10d %10f %10s' % (d, f, s)
'        37   3.140000 Fastcampus'
>>> '%14d %14f %14s' % (d, f, s)
'            37       3.140000     Fastcampus'
>>> '%-14d %-14f %-14s' % (d, f, s)
'37             3.140000       Fastcampus    '
>>> '%-14.3d %-14.3f %-14.3s' % (d, f, s)
'037            3.140          Fas           '
```

### 새 스타일 ({}, format)

```
{}.format(변수)
```

```python
# 기본형태
>>> '{} {} {}'.format(d, f, s)
'37 3.14 Fastcampus'

# 각 인자의 순서를 지정
>>> '{1} {2} {0}'.format(d, f, s)
'3.14 Fastcampus 37'

# 각 인자에 이름을 지정
>>> '{d} {f} {s}'.format(d=50, f=1.432, s='WPS')
'50 1.432 WPS'

# 딕셔너리로부터 변수 할당
>>> dict = {'d': d, 'f': f, 's': s}
>>> '{0[d]} {0[f]} {0[s]} {1}'.format(dict, 'WPS')
'37 3.14 Fastcampus WPS'

# 타입 지정자 입력
>>> '{:d} {:f} {:s}'.format(d, f, s)
'37 3.140000 Fastcampus'

# 이름과 타입지정자를 모두 사용
>>> '{digit:d} {float:f} {string:s}'.format(digit=700, float=1.4323, string='Welcome')
'700 1.432300 Welcome'

# 필드길이 10, 우측정렬
>>> '{:10d}'.format(d)
'        37'
>>> '{:>10d}'.format(d)
'        37'

# 필드길이 10, 좌측정렬
>>> '{:<10d}'.format(d)
'37        '

# 필드길이 10, 가운데 정렬
>>> '{:^10d}'.format(d)
'    37    '

# 필드길이 10, 가운데 정렬, 빈 공간은 ~로 채움
>>> '{:~^10d}'.format(d)
'~~~~37~~~~'
```

## 6\. 시퀀스 타입

파이썬에 내장된 시퀀스 타입에는 문자열, 리스트, 튜플이 있다.<br>
문자열은 인용부호(작은따옴표, 큰따옴표)를 사용하며, 리스트는 대괄호[], 튜플은 괄호()를 사용하여 나타낸다.<br>
시퀀스 타입의 객체는 인덱스 연산을 통해 내부 항목에 접근 할 수 있다.

### 리스트

리스트는 순차적인 데이터를 나타내는 데 유용하며, 문자열과는 달리 내부 항목을 변경할 수 있다.

- 리스트의 생성

```
>>> empty_list1 = []
>>> empty_list2 = list()
>>> sample_list = ['a', 'b', 'c', 'd']
>>> sample_list2 = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
```

- 다른 데이터를 리스트로 변환

**list** 함수를 사용

```python
>>> list('League of legends')
['L', 'e', 'a', 'g', 'u', 'e', ' ', 'o', 'f', ' ', 'l', 'e', 'g', 'e', 'n', 'd', 's']
```

이 외에도 리스트로 변환 가능한 타입에서 사용가능하다.

- 인덱스 연산

문자열과 같이 인덱스 형태로 내부 인자들을 연산할 수 있다.

- 내부항목 변경

리스트는 문자열과 다르게 내부항목을 변경할 수 있다. 해당 인덱스의 인자의 내용을 할당할 수 있다.

- 슬라이스 연산

- 리스트 항목 추가 (append)

```python
>>> sample_list.append('e')
>>> sample_list
['a', 'b', 'c', 'd', 'e']
```

- 리스트 병합 (extend, +=)

```
>>> fruits = ['apple', 'banana', 'melon']
>>> colors = ['red', 'green', 'blue']
>>> fruits.extend(colors)
>>> fruits
['apple', 'banana', 'melon', 'red', 'green', 'blue']
```

```
>>> fruits = ['apple', 'banana', 'melon']
>>> colors = ['red', 'green', 'blue']
>>> fruits += colors
>>> fruits
['apple', 'banana', 'melon', 'red', 'green', 'blue']
```

**extend** 대신 **append** 를 사용하면?

리스트에 리스트를 인자로 append메소드를 사용하면, 리스트 자체가 인자로 추가되므로, 항목들을 추가하려면 extend 메소드를 사용해야 한다.

- 특정 위치에 리스트 항목 추가 (insert)

리스트 함수 **insert(offset)** 을 사용

- fruits리스트의 1번째 위치에 'mango'를 추가해보자
- fruits리스트의 100번째 위치에 'pineapple'을 추가해보자

`fruits.insert(1, mango)`

- 특정 위치 리스트 항목 삭제 (del)

파이썬 구문 **del** 을 사용

> del은 리스트 함수가 아닌, 파이썬 구문이므로 `del <리스트>[오프셋]` 형식을 사용한다.

```
>>> del fruits[0]
```

- 값으로 리스트 항목 삭제 (remove)

```
>>> fruits.remove('mango')
```

- 리스트 항목 추출 후 삭제 (pop)

```
>>> fruits.pop()
>>> fruits.pop(-3)
```

pop은 삭제하면서 해당 값을 반환한다.

- 값으로 리스트 항목 오프셋 찾기 (index)

```
>>> fruits.index('red')
```

- 존재여부 확인 (in)

```
>>> 'red' in fruits
True
```

- 값 세기 (count)

```
>>> fruits.append('red')
>>> fruits.append('red')
>>> fruits.count('red')
3
```

- 정렬하기 (sort, sorted)

- sort는 리스트 자체를 정렬

- sorted는 리스트의 정렬 복사본을 반환

- 리스트 복사 (copy)

- copy함수

- list함수
- 슬라이스 연산[:]

list2 = list1

이 상태에서 list1의 값을 변경하면 list2도 자동으로 변경된다. 두 리스트가 가리키는 id값이 같기 때문이다. 그러므로 값 자체를 복사하기 위해서는 해당 메소드들을 사용해야 한다.

### 튜플

튜플은 리스트와 비슷하나, 정의 후 내부 항목의 삭제나 수정이 불가능하다.

- 튜플 생성

```python
>>> empty_tuple = ()
```

```python
>>> colors = 'red',
>>> color = 'red' - 문자열 생성임.
>>> fruits = 'apple', 'banana'
```

튜플을 정의할 때는 괄호가 없어도 무관하나, 괄호로 묶는것이 좀 더 튜플임을 구분하기 좋다.<br>
또한, 튜플의 요소가 1개일 때는 요소의 뒤에 쉼표(,)를 붙여야 한다.

- 튜플 언패킹

```python
>>> f1, f2 = fruits
```

값의 교환

- 형 변환

**tuple** 함수를 사용 (튜플 생성에는 사용 불가능)

리스트를 튜플로 변환

- 튜플을 사용하는 이유

- 리스트보다 적은 메모리 사용

- 정의후에는 변하지 않는 내부 값

### 딕셔너리(dictionary)

Key-Value형태로 항목을 가지는 자료구조.

- 딕셔너리 생성

```python
>>> empty_dict1 = {}
>>> empty_dict2 = dict()
>>> champion_dict = {
... 'Lux': 'the Lady of Luminosity',
... 'Ahri': 'the Nine-Tailed Fox',
... 'Ezreal': 'the Prodigal Explorer',
... 'Teemo': 'the Swift Scout',
... }
```

- 형변환

**dict** 함수를 사용, 두 값의 시퀀스(리스트 또는 튜플)을 딕셔너리로 변환 한다.

```python
>>> sample = [[1,2], [3,4], [5,6]]
>>> dict(sample)
{1: 2, 3: 4, 5: 6}
```

- 항목 찾기/추가/변경 [key]

```
>>> champion_dict['Lux']
'the Lady of Luminosity'
>>> champion_dict['Sona'] = 'Maven of the Strings'
>>> champion_dict['Lux'] = 'Demacia'
```

- 결합 (update)

```
>>> item_dict = {
... 'Doran\'s Ring': 400,
... 'Doran\'s Blade': 450,
... 'Doran\'s Shield': 450,
... }
>>> com_dict = {}
>>> com_dict.update(champion_dict)
>>> com_dict.update(item_dict)
>>> com_dict
```

서로 같은 키가 있을 경우, update에 주어진 딕셔너리의 값이 할당된다.

- 삭제 (del)

```
>>> del com_dict['Doran\'s Blade']
>>> del com_dict['Doran\'s Ring']
>>> del com_dict['Doran\'s Shield']
```

- 전체 삭제 (clear)

전체 항목을 삭제

- in으로 키 검색

True/False를 반환한다.

- 키 또는 값 얻기

**keys()**<br>
모든 키 얻기

**values()**<br>
모든 값 얻기

**items()**<br>
모든 키-값 얻기 (튜플로 반환)

- 복사

**copy()**

### 셋(Set)

셋은 키만 있는 딕셔너리와 같으며, 중복된 값이 존재할 수 없다.

- 셋 생성

```python
>>> empty_set = set()
>>> champions = {'lux', 'ahri', 'ezreal'}
```

- 형변환

문자열, 리스트, 튜플, 딕셔너리를 셋으로 변환할 수 있으며, 중복된 값이 사라진다.

```
>>> set('ezreal')
{'e', 'z', 'a', 'l', 'r'}
```

```
>>> set(champion_dict)
{'Ahri', 'Lux', 'Ezreal', 'Sona', 'Teemo'}
```

딕셔너리는 키만 남는다.

- 집합 연산

연산자 | 설명
--- | ----------------------
`   | `                      | 합집합(Union)
&   | 교집합(Intersection)
-   | 차집합(Difference)
^   | 대칭차집합(Exclusive)
<=  | 부분집합(Subset)
<   | 진부분집합(Proper subset)
>=  | 상위집합(Superset)
>   | 진상위집합(Proper superset)

```
>>> A = {1,2,3,4,5}
>>> B = {4,5,6,7,8,9}
>>> C = {4,5,6}
>>> A|B
>>> A&B
>>> A-B
>>> B-A
>>> A^B
>>> A <= B
>>> C <= B
>>> C < B
>>> B <= B
>>> B < B
```

## 7\. 제어문

### if, elif, else(조건문)

if와 else는 조건이 참인지 거짓인지 판단하는 파이썬 선언문(statement)이며, elif는 else 내의 if를 중첩해야 할 때 사용한다.

```
if 조건:
  조건이 참일 경우

조건이 참이 아니면 무시
```

```
if 조건:
  조건이 참일 경우
else:
  조건이 거짓일 경우
```

```
if 조건1:
  조건1이 참일 경우
else:
  조건1이 거짓일 경우

  if 조건2:
    조건1은 거짓이나, 조건2는 참일 경우
  else:
    조건1,2가 모두 거짓일 경우
```

위 코드는 아래와 같이 `elif`로 줄여쓸 수 있다.

```
if 조건1:
  조건1이 참일 경우
elif 조건2:
  조건1은 거짓이나, 조건2가 참일 경우
else:
  조건1,2가 모두 거짓일 경우
```

- 조건표현식

```
참일 경우 실행구문/ if / 조건식 / else / 거짓일 경우 실행구문
```

> 실습

`is_holiday`에 `True` 혹은 `False`값을 할당한 후 if문과 조건표현식을 사용해서 각각 'Good'과 'Bad를 출력하는 코드를 짜라'

```python
is_holiday=True
print('Good') if is_holiday else print('Bad')
Good

is_holiday=False
print('Good') if is_holiday else print('Bad')
Bad
```

- 중첩 조건표현식

```
# 조건이 2개일 경우
조건1이 참일 경우 if 조건1 else 조건1은 거짓이나 조건2가 참일 경우 if 조건2 else 조건1,2가 모두 거짓일 경우
```

> 실습

```
vacation에 1에서 10중 아무 값이나 할당 후, if, elif, else문과 중첩 조건표현식을 사용해서 각각 vacation이 7이상이면 'Good', 5이상이면 'Normal', 그 이하면 'Bad'를 출력하는 코드를 짜본다.
```

```python
vacation=3
print('Good') if vacation>=7 else print('Normal') if vacation>=5 else p rint('Bad')
Bad

vacation=6
Normal

vacation=8
Good
```

### for문 (조건에 따른 순회)

- 기본형태

시퀀스형 데이터를 순회하고자 할 때 사용한다.

```
for 항목 in 순회가능(iterable)객체:
  <항목을 사용한 코드>
```

iterable한 객체에는 문자열, 튜플, 딕셔너리, 셋 등이 있다.

```python
>>> champion_list = ['lux', 'ahri', 'ezreal', 'zed']
>>> for champion in champion_list:
...   print(champion)
...
lux
ahri
ezreal
zed
```

딕셔너리에서 키나 값을 순회할 때는, iterable한 객체의 위치에 dict.keys()나 dict.values()를 사용한다. 키, 값을 모두 순회할 때에는 dict.items()를 사용한다.

- 중첩

```
for 항목1 in iterable객체1:
  iterable객체1을 순회하며 실행할 코드
  for 항목2 in iterable객체2:
    iterable객체1 내부에서 새로운 iterable객체2를 순회하며 실행할 코드
```

- 중단하기(break)

데이터를 순회하던 중, 특정 조건에서 순회를 멈추고 반복문을 빠져나갈 때 사용한다.

```
for 항목 in iterable객체:
  (반복문을 중단하고 싶을 때)break
```

- 건너뛰기continue)

데이터를 순회하던 중, 반복문을 중단하지 않고 다음 반복으로 건너뛸 때 사용한다.

```
for 항목 in iterable객체:
  (현재의 반복을 중간에 그만두고 다음 반복으로 건너뛰고 싶을 때)continue
```

- break확인 (else)

for문으로 데이터를 순회하던 중, break문이 호출되지 않고 반복문이 종료되면 else문이 실행된다.

```
for 항목 in iterable객체:
  pass
else:
  break가 한 번도 호출되지 않았을 경우의 코드
```

- 여러 시퀀스 동시순회 (zip)

```python
>>> fruits = ['apple', 'banana', 'melon']
>>> colors = ['red', 'yellow', 'green', 'purple']
>>> for fruit, color in zip(fruits, colors):
...   print('fruit:', fruit, 'color:', color)
...
fruit: apple  color: red
fruit: banana  color: yellow
fruit: melon  color: green
```

zip으로 묶은 시퀀스들 중, 가장 짧은 시퀀스가 완료되면 순회가 종료된다.

zip을 사용하면 여러 시퀀스로부터 튜플을 만들 수 있다.

```
>>> list(zip(fruits, colors))
```

zip으로 반환되는 것은 리스트가 아닌 zip클래스 형태의 iterable객체이기 때문에, 리스트 형태로 사용하려면 list()함수를 사용해준다.

dict()함수를 사용할 경우 딕셔너리 개체가 만들어지게 된다.

> 실습 - zip 없이 두 시퀀스 동시에 순회하기

```python
fruits = ['apple', 'banana', 'melon']
colors = ['red', 'yellow', 'green', 'purple']

index = 0

for fruit in fruits:
        print(fruit, colors[index])
        print('fruit(%s), color(%s)' % (fruit, colors[index]))
        index +=1


print(zip(fruits, colors)) - zip object
```

- 숫자 시퀀스 생성(range)

range()함수는 특정 범위의 숫자 스트림 데이터를 반환한다.

range(0,10) - 0부터 10 미만까지

```
range(start, stop, step)
```

zip과 마찬가지로, iterable한 객체를 반환하며, 따라서 for문을 순회할 수 있다.

```python
>>> for x in range(0,10):
...   print(x)
...
0
1
2
3
4
5
6
7
8
9
```

### while문

for문과 유사하나, while뒤의 조건이 참일 경우에 계속해서 반복한다.

```
while 조건:
  조건이 참일경우 실행
  조건이 거짓이 될 경우까지 계속해서 반복
```

```python
>>> count = 0
>>> while count < 10:
...   print(count)
...   count += 1
...
0
1
2
3
4
5
6
7
8
9
```

## 8\. 컴프리헨션(Comprehension)

> 함축 또는 내포

iterable한 객체로부터 파이썬의 자료구조를 만드는 방법. 가독성과 사용성에서 이득을 얻을 수 있을 경우 항상 사용해준다.

### 리스트 컴프리헨션

```
[표현식 for 항목 in iterable객체]
```

[1,2,3,4,5]를 만드는 방법

_range와 for문을 사용할 경우_

```python
>>> numbers = []
>>> for item in range(1,6):
...   numbers.append(item)
...
>>> numbers
[1,2,3,4,5]
```

_리스트 컴프리헨션을 사용할 경우_

```python
>>> [item fo item in range(1,6)]
[1,2,3,4,5]
```

- 리스트 컴프리헨션의 중첩

```
for color in colors:
  for fruit in fruits:
```

```
[(color, fruit) for color in colors for fruit in fruits]
```

> 실습 리스트 컴프리헨션 - 짝수 항목만 리스트화 하기

[item for item in range(1,6) if item%2 == 0]

[표현식 for 항목 in iterable객체 조건문]

### 셋 컴프리헨션

```
{표현식 for 표현식 in iterable객체}
```

실습

1. for문을 2개 중첩하여 0,0 -> 6,3까지 출력

```python
for item1 in range(0,7):
    for item2 in range(0,4):
        print('(%d, %d)' % (item1, item2))
```

1. 리스트 컴프리헨션으로 위 항목 생성

`['(%d, %d)' % (item1, item2) for item1 in range(0,7) for item2 in range(0,4)]`

문자열로 리스트

`l2 = [(x,y) for x in range(7) for y in range(4)]`

튜플로 리스트

1. 1, 2번의 반복문에서 1번은 튜플의 첫 번째 항목이 짝수일때만 출력하도록,

  2번은 첫 번째 항복이 짝수일때만 리스트의 원소로 추가

```python
for item1 in range(0,7):
    for item2 in range(0,4):
        if item1%2==0:
            print(item1,item2)

l= [(item1, item2) for item1 in range(0,7) for item2 in range(0,4) if item1%2==0]
```

1. 1000에서 2000까지 숫자 중, 홀수의 합을 구해본다.

```python
result = 0
for i in range(1000, 2001):
    if i%2==1:
        result+=i

print(result)
```

# 컴프리헨션과 내장함수 sum 이용

```python
result= sum([x for x in range(1000,2001) if x % 2 ==1])
print(result)
```

# sum - iterable 내의 값을 모두 더해주는 내장함수

# 더 효율적인 방법으로 step 사용

```python
result = sum([x for x in range(1001,2000,2)])
print(result)
```

5.

```python
gugu=[item1*item2 for item1 in range(2,10) for item2 in range(1,10)]
index = 0

for x in range(2,10):
    for y range(1,10):
        print('%d X %d = %d'(x,y,gugu[index]))
        index+=1

#기초적인 방법
l = ['%d x %d = %d' % (x, y, x*y) for x in range(2,10) for y in range(1,10)]


# 현재 출력중인 결과가 구구단 중 '몇'단에 해당하는지의 index
gugu_index = 2
# 전체 구구단 결과 리스트 중 몇 번째를 순회하고 있는지의 index
list_index = 0
for item in l:
    #전체 구구단 리스트의 아이템 중 9번째마다 실행
    if list_index % 9 ==0:
        print('== %s단 ==' % gugu_index)
        # 한 번 '몇'단인지 출혁 후에는 다음 단의 index를 저장
        gugu_index += 1
    # 전체 구구단 결과 리스트 중 몇 번째를 순회하는 중인지 업데이트
    list_index += 1
    # 전체 구구단 결과 중 현재 순회중인 item을 출력
    print(item)


# enumerate 내장함수 사용, index를 생략
for list_index, item in enumerate(l):
    if list_index % 9 ==0:
        print('== %단 ==' % gugu_index)
        gugu_index += 1
    print(item)

#dict를 사용해서 gugu_index를 구구단 자료구조내에 포함
#for 문으로 순회 시, 각 리스트의 항목이 dict가 되도록 한다.
# 각 dict는 자신이 '몇단'인지의 정보와 9개의 결과 리스트를 갖는다.
/*
gugu_iist =

for i in range(2,10):
    {'title':'%d단'(% i),'items':['%d x %d = %d' % (i,y,i*y) for y in range(1,10)] }
*/

# 정답

gugu_list = [ {'title':'%d단' % (x), 'items':['%d x %d = %d' % (x, y, x*y) for y in range(1,10)] } for x in range(2,10)]

print(gugu_list)


for gugu in gugu_list:
    print(gugu['title'])
    for item in gugu['items']:
        print(item)
    print('')
```

1. 7의 배수이거나 9의 배수인 숫자의 리스트, 7의 배수이면서 9의 배수인 수는 한 번만 추가

```python
list79=sorted(list(set([result for x in range(1,99) if x%7==0 or x%9==0])))

result = []
for x in range(1,100):
    if x % 7 == 0 or x % 9 == 0:
        result.append(x)

print(result)
```

## 제네레이터 컴프리헨션

```
(표현식 for 표현식 in iterable객체)
```

괄호로 되어있지만 튜플을 생성하지 않는다. (튜플은 컴프리헨션이 없다.)

제네레이터 객체는 순회 가능하며, 리스트 형태로 만들 수 있다.

## 9\. 함수

반복적인 작업을 하는 코드를 재사용이 가능하게 정의해 놓은 것.

```python
def 함수명(매개변수[parameters]):
  동작
```

### 함수의 정의, 실행

```python
# 실행 시 'call func'를 print하는 함수 정의
>>> def func():
...   print('call func')
...

# 함수 자체는 function객체를 참조하는 변수
>>> func
<function func at 0x10dabf378>

# 함수를 실행시키기 위해 () 사용
>>> func()
call func
```

### 리턴값이 있는 함수 정의

```python
>>> def return_true():
...   return True
...
>>> return_true()
True
```

함수의 결과로 Bool 값을 갖는 데이터를 리턴하여 if문이나 while문의 조건으로 사용 가능하다.

### 매개변수를 사용하는 함수 정의

```python
>>> def print_arguments(something):
...   print(something)
...
>>> print_arguments('ABC')
ABC
```

### 매개변수(parameter)와 인자(argument)의 차이

함수 내부에서 함수에게 전달되어 온 변수는 매개변수라 부르며, 함수를 호출할 때 전달하는 변수는 인자로 부른다.

```python
# 함수 정의때는 매개변수
def func(매개변수1, 매개변수2):
  ...

# 함수 호출시에는 인자
>>> func(인자1, 인자2)
```

### 리턴값이 없을 경우

함수에서 리턴해 주는 값이 없을 경우, 아무것도 없다는 뜻을 가진 'None' 객체를 얻는다.

### 위치 인자(Positional argument)

매개변수의 순서대로 인자를 전달하여 사용하는 경우

```python
>>> def student(name, age, gender):
...   return {'name': name, 'age': age, 'gender': gender}
...
>>> student('hanyeong.lee', 30, 'male')
{'name': 'hanyeong.lee', 'age': 30, 'gender': 'male'}
```

### 키워드 인자(Keyword argument)

매개변수의 이름을 지정하여 인자로 전달하여 사용하는 경우

```python
>>> student(age=30, name='hanyeong.lee', gender='male')
{'name': 'hanyeong.lee', 'age': 30, 'gender': 'male'}
```

**위치인자와 키워드인자를 동시에 쓴다면, 위치인자가 먼저 와야 한다.**

함수 호출시의 이야기...

### 기본 매개변수값 지정

인자가 제공되지 않을 경우, 기본 매개변수로 사용할 값을 지정할 수 있다. 인자를 제공하면 무시된다.

```python
>>> def student(name, age, gender, cls='WPS'):
...   return ('name': name, 'age': age, 'gender': gneder, 'class': cls)
...
>>> student('hanyeong lee', 30, 'male')
{'name': 'hanyeong lee', 'age': 30, 'gender': 'male', 'class': 'WPS'}
```

### 기본 매개변수값의 정의 시점

> 기본 매개변수값은 함수가 실행될 때 마다 계산되지 않고, 함수가 정의되는 시점에 계산되어 계속해서 사용된다.

```python
>>> def return_list(value, result=[]):
...   result.append(value)
...   return result
...
>>> return_list('apple')
['apple']
>>> return_list('banana')
['apple', 'banana']
```

현재 **result** 가 한번만 계산되고(id가 일치) 계속 쓰이고 있음을 알 수 있다. 그래서 append 메소드가 연속된다.

함수가 실행되는 시점에 기본 매개변수값을 계산하기 위해, 아래와 같이 바꿔준다.

```python
# result 매개변수에 인자를 집어넣지 않았다는 의미
>>> def return_list(value, result=None):
...   if result is None:
...     result = []
...   result.append(value)
...   return result
...
>>> return_list('apple')
['apple']
>>> return_list('banana')
[banana]
```

### 위치인자 묶음

함수에 위치인자로 주어진 변수들의 묶음은 `*매개변수명`으로 사용할 수 있다.<br>
관용적으로 `*args`를 사용한다.

```python
def print_args(*args):
  print(args)
```

몇 개든 다 받을 수 있다.

### 키워드인자 묶음

함수에 키워드인자로 주어진 변수들의 묶음은 `**매개변수명`으로 사용할 수 있다. 관용적으로 `**kwargs`를 사용한다.

```python
def print_kwargs(**kwargs):
  print(kwargs)
```

```python
def print_all_args(*args, **kwargs):
  print(args)
  print(kwargs)
```

> 실습

```python
def practice(*args):
  if enumerate(*args) ==2:
    return *args[0] * *args[1]
  elif enumerate(*args) ==1:
    return *args**2
  else
    print('다시 입력하세요')

#정답

def mul(*args):
  if len(args) ==1:
    return args[0] ** 2
  elif len(args) ==2:
    return args[0] * args[1]
```

### docstring

함수를 정의한 문서 역할을 한다. 함수 정의 후, 몸체의 시작부분에 문자열로 작성하며, 여러줄로도 작성 가능하다.

```python
>>> def print_args(*args):
...   'Print positional arguments'
...   print(args)
...
>>> help(print_args)
```

### 함수를 인자로 전달

파이썬에서는 함수 역시 다른 객체와 동등하게 취급되므로, 함수에서 인자로 함수를 전달, 실행, 리턴하는 형태로 프로그래밍이 가능하다.

> 실습

- 'call func'를 출력하는 함수를 정의하고, 함수를 인자로 받아 실행하는 함수를 정의하여 첫 번째에 정의한 함수를 인자로 전달해 실행해보자.

```python

def args_func(func):
  func()

def print_call_func():
  print(call func)

print(print_call_func)
print(print_call_func())
```

### 내부 함수

함수 안에서 또 다른 함수를 정의해 사용할 수 있다.

> 실습

- 문자열 인자를 하나 전달받는 함수를 만들고, 해당 함수 내부에 전달받은 문자열을 대문자화해서 리턴해주는 내부 함수를 구현한다.<br>
  문자열을 전달받는 함수는 내부함수를 실행한 결과를 리턴하도록 한다.

```python
def string_func('x'):
  def string_cap_func('x'):
    return upper('x')
  print(string_cap_func())
```

### 스코프(영역)

파이썬에서는 코드 작성 시, 각 함수마다 독립적인 스코프(영역)을 가진다.<br>
메인 프로그램(현재 동작하는 프로그램의 최상위 위치)의 영역은 전역 영역(Global Scope)라고 하며, 전역 스코프 내부에서 독립적인 영역을 갖고 있는 경우에는 지역 영역(Local Scope)라고 부른다.

아래 코드의 경우, `show_global_champion`함수 내부의 영역은 별개의 로컬 스코프를 가지며, `champion`변수는 전역 영역의 것을 가져와 출력하는것을 볼 수 있다.

```python
champion = 'Lux'

def show_global_champion():
    print('show_global_champion : {}'.format(champion))
    print(f'show_global_champion: {champion}')
show_global_champion()
print('print champion : {}'.format(champion))
```

위 코드를 아래와 같이 변경 후, 실행 해 본다.

```python
champion = 'Lux'

def show_global_champion():
    print('show_global_champion : {}'.format(champion))

def change_global_champion():
    print('before change_global_champion : {}'.format(champion))
    champion = 'Ahri'
    print('after change_global_champion : {}'.format(champion))

show_global_champion()
change_global_champion()
```

`change_global_champion`함수에서 오류가 발생한다.

두 번째 함수는 첫 번째 줄부터 오류. 1\. 두 번째 함수는 로컬 영역에 해당 변수가 존재하지만, 할당 전에 호출하기 때문에 오류가 나는 것이다. 로컬 스코프 내의 변수가 어디든 정의되어 있다면 그 변수만을 참조한다. 3\. 스코프 내에 같은 이름의 변수가 없다면 스코프 외부의 변수를 찾는다.

첫 번째 코드에서는 `champion`변수가 함수의 로컬 스코프에 존재하지 않기 때문에 글로블 스코프에서 해당 변수를 찾아 출력하였으나, 이번 코드에서는 내부에 또다른 `champion`변수가 존재하기 때문에 할당하기 전인 변수를 사용한 것으로 판단하여 프로그램에서 오류를 발생시킨다.

```python
def show_global_champion():
    print('g_id:' id(champion))
    print('show_global_champion : {}'.format(champion))

def change_global_champion():
#    print('before change_global_champion : {}'.format(champion))
    champion = 'Ahri'
    print('c_id:' id(champion))
    print('after change_global_champion : {}'.format(champion))
```

이름이 같은 두 변수가 다른 객체임을 내장함수 `id`를 사용해 확인해보자.

아이디가 다르다는 것을 알 수 있다.

또한, 각 영역에 현재 스코프에 해당하는 데이터들은 `locals()`함수를 사용해 확인 할 수 있으며, 전역 영역의 데이터들은 `globals()`함수를 사용한다.

### 스코핑 룰

스코프는 지역(Local), 전역(Global)외에도 내장(Built-in)영역이 존재하며, 내장영역이 가장 바깥, 그 내부에 전역, 그 내부에 지역 순으로 정의된다. - 내장함수들이 들어 있는 곳 분리된 영역에서, 외부 영역에서는 내부 영역의 데이터를 사용할 수 없지만 내부 영역에서는 자신의 외부 영역에 있는 데이터를 참조할 수 있다.<br>
(반대의 경우에는 함수의 인자로 데이터를 전달한다)

### 내장 함수와 내장 영역

`print`, `dict`등 지정하지 않고 사용했던 내장 함수들은 위 스코핑 룰의 내장 스코프에 존재하는 함수들이다.<br>
전역스코프의 `__builtin__`변수에 할당되어 있으며, 전역 스코프에서는 해당 변수의 내부를 참조할 수 있도록 파이썬이 시작될 때 자동으로 처리된다.

확인시 `dir`함수를 사용하며, `dir`함수는 해당 객체가 사용 가능한 속성 및 함수들을 리스트 형태로 나타내준다.

### 로컬 스코프에서 글로벌 스코프의 변수를 사용

```python
champion = 'Lux'

def change_global_champion():
    champion = 'Ahri'
    print('after change_global_champion : {}'.format(champion))

change_global_champion()
print('print global champion : {}'.format(champion))
```

이 경우, 위의 `show_global_champion`함수와는 다르게 `change_global_champion`함수는 `champion`변수에 새로운 값을 대입한다.<br>
만약 로컬 스코프에서 글로벌 스코프의 변수를 변경해야 한다면, 해당 변수가 로컬 스코프에 생성되는 것이 아닌 글로벌 영역에 이미 존재하는 값을 사용함을 명시해주어야 한다.

```python
champion = 'Lux'

def change_global_champion():
    global champion
    champion = 'Ahri'
    print('after change_global_champion : {}'.format(champion))
# 전역변수를 참조하여 변경한 것이므로 전역의 champion변수도 Ahri로 변경된다.



change_global_champion()
print('print global champion : {}'.format(champion))
```

> 실습

```python
champion='Lux'

def change_global_champion():
  global champion
  print(id(champion))
  champion = 'Ahri'
  print('after change_global_champion : {}'.format(champion))
  print(id(champion))
```

파이썬에서는 한 스코프에서 동일한 이름을 가진 두 스코프의 변수를 사용할 수 없음을 기억해야 한다.

### 내부함수에서의 로컬 스코프 (nonlocal)

```python
champion = 'Lux'

def local1():
    champion = 'Ahri'
    print('local1 locals() : {}'.format(locals()))

    def local2():
        champion = 'Ezreal'
        print('local2 locals() : {}'.format(locals()))
    local2()

print('global locals() : {}'.format(locals()))
local1()
```

로컬 스코프 내부에는 또 다른 로컬 스코프가 존재할 수 있다.<br>
로컬에서 해당 변수가 없어 외부에서 참조하려고 한다면 한 스코프씩 올라가게 된다. 전역 스코프가 아닌, 자신의 바로 바깥 영역의 로컬 스코프(자신보다 한 단계 위의 로컬 스코프)의 데이터를 참조하고자 한다면, `nonlocal`키워드를 사용한다. - python3부터 추가된 키워드 - 참조할 수 있는 영역까지 올라간다.

```python
champion = 'Lux'

def local1():
    champion = 'Ahri'
    print('local1 locals() : {}'.format(locals()))

    def local2():
        nonlocal champion
        champion = 'Ezreal'
        print('local2 locals() : {}'.format(locals()))
    local2()
    print('local1 locals() : {}'.format(locals()))

print('global locals() : {}'.format(locals()))
local1()
```

### global키워드와 인자(argument)전달의 차이

인자로 전달한 경우

```python
global_level = 100
def level_add(value):
    print(id(value)) - 매개변수와 인자의 id가 같은 순간
    value += 30
    print(value)     - 원래 인자와 변화된 매개변수가 가리키는 곳이 다르다
    print(id(value))  - value는 함수가 끝나고 사라지고, global_level은 그대로 남아있다.

print(id(global_level))
level_add(global_level)
print(global_level)
```

global키워드를 사용한 경우

```python
global_level = 100
def level_add():
    global global_level
    global_level += 30
    print(global_level)

level_add()
print(global_level)
```

인자로 전달한 경우, 같은 객체를 가리키는 글로벌 변수 `global_level`과 매개변수 `value`가 존재한다.<br>
이 때, 매개변수인 `value`의 값을 변경하는 것은 `global_level`에는 영향을 주지 않는다.

global키워드의 경우 둘은 같은 변수이다.

하지만 리스트 변수가 전달된다면?

> 실습

```python
global_list = [100]

def level_add(l):
  l[0] +=30

print(global_list) 100
level_add(global_list) - 130
print(global_list) - 130
```

리스트 내 원소의 값(가리키는 객체)가 변화된 것.

### 람다함수

한 줄 짜리 표현식으로 이루어지며, 반복문이나 조건문 등의 제어문은 포함될 수 없다.<br>
또한, 함수이지만 정의/호출이 나누어져 있지 않으며 표현식 자체가 바로 호출된다.

```python
lambda <매개변수> : <표현식>
```

```
# 함수의 정의
>>> def multi(x):
...   return x*x
...

# 함수의 호출
>>> multi(5)
25

# 람다함수의 사용
>>> (lambda x : x*x)(5)
25

# 람다함수를 사용해 함수 정의
>>> f = lambda x : x*x
>>> f(5)
25
```

### 람다함수의 사용

```python
import string
>>> for char in string.ascii_lowercase:
...   if char > 'i':
...     print(char.upper())
...   else:
...     print(char)
```

```
>>> for char in string.ascii_lowercase:
...   print((lambda x : x.upper() if x > 'i' else x)(char))
```

### 클로져 (Closure)

함수가 정의된 환경을 말하며, 파이썬 파일이 여러개일 경우 각 파일은 하나의 `모듈`역할을 하고, 각 `모듈`은 독립적인 환경을 가진다.<br>
독립된 환경은 각자의 영역을 전역 영역으로 사용한다.

**closure/module_a.py**

```python
level = 100
def print_level():
    print(level)
```

**closure/module_b.py**

```python
import module_a - 네임스페이스
level = 50
def print_level():
    print(level)

module_a.print_level()
print_level()
```

`python module_b.py`로 `module_b`를 실행한다.

함수의 전역 영역은 해당 함수가 정의된 모듈의 전역 영역으로, 전역변수는 모듈의 영역에 영향을 받는다.

### 내부함수의 클로져

```python
>>> level = 0
>>> def outer():
# outer 함수의 지역변수 level
...   level = 50
...   def inner():
#outer의 level을 참조
...     nonlocal level

...     level += 3
#outer의 level을 출력
...     print(level)
# outer함수는 자신의 내부에서 정의된 inner 함수를 리턴
...   return inner
...
>>> func = outer() - 53
>>> func = outer() - 56 - outer가 실행될 때마다 inner가 outer의 변수를 변화시킨다. 자기가 동작할 수 있을 만큼의 영역을 가진다는 것이다. nonlocal로서 참조한 level 변수까지의 영역을 암시적으로 가지고 있다.
>>> func2 = outer() - 53(?) - func2 id 자체가 func와 다르므로 서로 독립된 영역이다.
```

위의 경우, `outter`함수는 `inner`함수를 반환하여 결과를 `func`전역변수에 할당한다.<br>
`inner`함수의 호출 결과가 아닌 함수 자체를 반환하기 때문에, `func`변수는 실행할 수 있는 함수객체이다.<br>
이 때 `inner`함수가 사용하는 `level`변수는 `nonlocal`키워드를 사용했기 때문에 `outter`에 새로 정의된 지역변수 `level`을 사용한다.<br>
반복적으로 `func`함수를 실행하면 `inner`의 외부(`outter`)에 존재하는 `level`변수의 값을 증가시키고 `print`시키기 때문에, 값은 계속해서 증가한다.

스코프 내부의 변수는 리턴하지 않으면 없어지지만, 스코프 외부의 변수를 참조하고 있다면 저장한다.

func2를 만든다면?

### 데코레이터 (decorator)

함수를 받아 다른 함수를 반환하는 함수. 예를 들면, 기존에 존재하던 함수를 바꾸지 않고 전달된 인자를 보기위한 디버깅 `print`함수를 추가한다던가 하는 기능을 할 수 있다.

1. 기능을 추가할 함수를 인자로 받음
2. 데코레이터 자체에 추가할 기능을 함수로 정의
3. 인자로 받은 함수를 데코레이터 내부에서 적절히 호출
4. 위 2가지를 행하는 내부 함수를 반환

아래와 같이 함수 2개를 만들고, 새 구문을 추가해본다.

- 인자로 문자열 변수를 받아 출력해주는 함수 `print_string`구현
- 인자로 정수형 변수를 받아 출력해주는 함수 `print_int`구현
- 각 함수에 대해 자신이 전달받은 인자에 대한 `type`을 출력하는 구문을 추가

여러 함수에 대해 같은 기능을 추가할 경우, 데코레이터를 사용한다.

```python
def print_debug(func):
    def inner_func(*args, **kwargs):
        print('args :', args)
        print('kwargs :', kwargs)
        result = func(*args, **kwargs)
        return result
    return inner_func
```

데코레이터함수(인자로 전달할 함수) 형태로도 사용이 가능하지만, 데코레이터를 사용할 경우에는 함수 위에 데코레이터를 추가해서 사용가능하다.

함수를 받아서 원래 동작/ 추가된 기능 동작까지 함께 하도록 감싸는 방법.

데코레이터 표현법 - 미리 정의를 해 두고 `@함수이름` 으로 데코레이터로 감쌀 수 있다. 데코레이터가 여러 개면 가장 밑에서부터 실행된다.

```python
@print_debug
def any_func():
    pass
```

또한 데코레이터는 여러개를 가질 수 있으며, 함수에서 가장 가까운 것 부터 실행한다.

- print_debug이후 결과를 제곱하고 print해주는 데코레이터를 실행, 반대로 실행

### 제네레이터 (generator)

제네레이터는 함수는 파이썬의 시퀀스 데이터를 생성하는데 사용된다. 실제 시퀀스 데이터와 다른 점은, 시퀀스 전체를 가지고 있는 것이 아니라 시퀀스 데이터를 생성하기 위한 어떠한 루틴만을 가지고 있는 것이다.<br>
이 방식을 택했을 때의 장점은, 전체 크기만큼의 메모리를 가지고 있는 시퀀스 데이터와는 달리 메모리를 적게 사용할 수 있다.

제네레이터는 마지막으로 호출한 위치(항목)에 을 기억하고 있으며, 한 번 순회할 때 마다 그 다음 값을 반환한다.

제네레이터는 함수를 통해서 만들어지며, 함수 내부의 반복문에서 `yield`키워드를 사용하면 제네레이터가 된다.

```python
>>> def range_gen(num):
...   i = 0
...   while i < num:
...     yield i
...     i += 1
...
>>> gen = range_gen(10)
>>> gen
<generator object range_gen at 0x10b682168>
>>> type(gen)
<class 'generator'>
>>> gen.__next__()
0
>>> gen.__next__()
1
>>> gen.__next__()
2
>>> gen.__next__()
3
>>> gen.__next__()
4
>>> gen.__next__()
5
>>> gen.__next__()
6
>>> gen.__next__()
7
>>> gen.__next__()
8
>>> gen.__next__()
9
>>> gen.__next__()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

함수 내부에 `yield`키워드가 사용되어 제네레이터 함수가 되었으며, 함수를 실행하면 제네레이터 객체를 반환한다.<br>
`yield`부분에서 멈춘 제네레이터 객체를 순회하기 위해서는 `__next__()` 함수를 실행해준다.

### 실습

1. 매개변수로 문자열을 받고, 해당 문자열이 `red`면 `apple`을, `yellow`면 `banana`를, `green`이면 `melon`을, 어떤 경우도 아닐 경우 `I don't know`를 리턴하는 함수를 정의하고, 사용하여 `result`변수에 결과를 할당하고 `print`해본다.

1. 1번에서 작성한 함수에 `docstring`을 작성하여 함수에 대한 설명을 달아보고, `help(함수명)`으로 해당 설명을 출력해본다.

1. 한 개 또는 두 개의 숫자 인자를 전달받아, 하나가 오면 제곱, 두개를 받으면 두 수의 곱을 반환해주는 함수를 정의하고 사용해본다.

1. 두 개의 숫자를 인자로 받아 합과 차를 튜플을 이용해 동시에 반환하는 함수를 정의하고 사용해본다.

1. 위치인자 묶음을 매개변수로 가지며, 위치인자가 몇 개 전달되었는지를 print하고 개수를 리턴해주는 함수를 정의하고 사용해본다.

1. 람다함수와 리스트 컴프리헨션을 사용해 한 줄로 구구단의 결과를 갖는 리스트를 생성해본다

--------------------------------------------------------------------------------

### 알고리즘

- 순차검색

- 선택정렬

```python
#1\. 순차 검색(sequential search)
# 문자열과 키 문자 1개를 받는 함수 구현
# while문을 이용하여 문자열에서 키 문자가 존재하는 index 위치 검사 후 해당 index 리턴
# 찾지 못할 경우 0 리턴
def seqsearch(searchingstr, key_char):
    index = 0

    while index < len(searchingstr):

        if key_char == searchingstr[index]:
            key_char = '{}'.fomat(index)
            index+=1
        else:
            index+=1
    if key_char is type(int):
        return  key_char
    else:
        return -1


# 답

def searchin(s,key):
    index=0
    while index < len(s):
        cur_char = s[index]
        if cur_char == key:
            return index
        index+=1

    return -1

#

def sequentialserch(ss, key2):
    for i, char in enumerate(ss):
        if key2 == char:
            return i
        return -1


def selectionsort(sss):
    for i in range(len(sss)-1):
        min = i
        for j in range(i, len(sss)):
            if sss[i]>sss[j]:
                min=j
        sss[min], sss[i], = sss[i], sss[min]
    return sss


def selectionsort2(seq):
    # 정렬할 리스트의 길이
    seq_len = len(seq)
    #최소값과 최소값의 index변수
    min_value = seq[0]
    min_index = 0
    # 전체 리스트를 순회하며 최소값을 판단
    for i in range(seq_len):
        cur_item = seq[i]
        print('Index[%d], value[%d]' % (i, cur_item))
        #만약 현재 요소가 min_value보다 작다면
        if cur_item < min_value:
            min_value = cur_item
            min_index = i
            print('Index[%d]는 현재 min_value(%s)보다 작음' % i , min_value)
            print('변경된 min_value: %d' % min_value)
            print('변경된 min_index: %' % min_index)

        # 한 번의 순회 후 min_index와 맨 앞의 요소를 치환
    seq[0], seq[min_index] = seq[min_index], seq[0]

    return seq


#for 문을 전체 아이템수 -1 번만큼 순회하며, 각 순회마다 index값을 증가시키며 seq[index]부터 끝까지의 리스트를 출력하도록 작성
def selectionsort3(seq2):

    #0부터 전체갯수 - 1 만큼 i값을 증가시키며 순회
    for i in range(len(seq2)-1):
        # 각 순회마다 i: 만큼의 리스트를 출력
        print(seq2[i:])

def selectionsort4(seq3):
    for i in range(len(seq3)):
        print('lood[%d], current list: %s' % (i, seq3))
        min_index = i
        min_value = seq3[i]
        for j in range(i, len(seq3)):
            if seq3[j] < min_value:
                print('index[%d](%d)는 현재 min_value(%d)보다 작음' % (j, seq3[j], min_value))
                min_index = i + j
                min_value = seq3[min_index]
        seq3[i] , seq3[min_index] = seq3[min_index], seq3[i]
```

## 10. 모듈과 패키지

### 모듈

지금까지 셸에서 진행한 실습의 경우, 하나의 모듈 내부에서 작업한 것으로 취급된다.

파이썬 파일은 각각 하나의 모듈로 취급되며, 실행이나 함수의 정의, 단순 변수의 모음 등등 여러 역할을 한다.

#### 모듈 불러오기 (import)

기본 게임모듈에서, 부가적인 기능들을 불러와서 사용하는 형태로 코드를 작성해본다.

**module/shop.py**

```python
def buy_item():
    print('Buy item!')

buy_item()
```

**module/game.py**

```python
def play_game():
    print('Play game!')

play_game()
```

**module/lol.py**

```python
import game
import shop

print('= Turn on game =')
game.play_game()
shop.buy_item()
```

#### __name__변수

`lol.py`가 실행될 때, `game`과 `shop`가 import되는 순간 해당 코드가 실행되어 버리는 문제가 있다.

이 때, 파이썬 인터프리터를 이용해 실행한 코드인지를 확인하여 단순히 `import`한 모듈의 경우 실행을 막는 방식을 사용할 수 있다.

각 모듈은 자신의 이름을 가지며, 모듈 이름은 모듈의 전역변수 `__name__`에서 확인 할 수 있다.

```
print(__name__)
```

파이썬 인터프리터가 실행한 모듈의 경우, `__main__`이라는 이름을 가진다. 따라서 `python <파일명>`으로 실행한 경우에만 동작할 부분은 if문으로 감싸준다.

**module/shop.py**

```python
def buy_item():
    print('Buy item!')

if __name__ == '__main__':
    buy_item()
```

**module/game.py**

```python
def play_game():
    print('Play game!')

if __name__ == '__main__':
    play_game()
```

다시 `lol.py`를 실행해본다.

#### lol.py 리펙토링

```python
import game
import shop

def turn_on():
    print('= Turn on game =')

    while True:
        choice = input('What would you like to do?\n  1: Go to Shop, 2: Play Game, 0: Exit\n    Input : ')
        if choice == '0':
            break
        elif choice == '1':
            shop.buy_item()
        elif choice == '2':
            game.play_game()
        else:
            print('Choice not exist')
        print('-----------------------')

    print('= Turn off game =')

if __name__ == '__main__':
    turn_on()
```

#### 네임스페이스 (Namespace)

각 모듈은 독립된 네임스페이스(이름공간)를 가진다. 메인으로 사용되고 있는 모듈이 아닌 import된 모듈의 경우, 해당 모듈의 네임스페이스를 사용해 모듈 내부의 데이터에 접근한다.

같은 함수명을 가진 모듈을 2개 만들고, 한 쪽에서 다른 한 쪽의 모듈을 import 한 뒤 각각의 모듈의 함수를 실행시켜본다.

#### from을 사용해 모듈의 함수를 직접 import

`import 모듈명`의 경우, 모듈의 이름이 전역 네임스페이스에 등록되어 `모듈명.함수`로 사용가능하다.

모듈명을 생략하고 모듈 내부의 함수를 쓰고 싶다면, `from 모듈명 import 함수명`으로 불러들일 수 있다.

#### from 모듈명 * 을 사용해 모듈 내 모든 식별자 (변수, 함수) import

#### as로 별칭 할당

`from 모듈명 import` 또는 `import 모듈명`에서, 같은 모듈명이 존재하거나 혼동 될 수 있을 경우, 뒤에 `as`를 붙여 사용할 모듈명을 변경할 수 있다.

#### 커맨드라인에서 인자 전달

프로그램 실행 시 인자를 전달 할 수 있다. 파이썬의 내장`sys`모듈의 `argv`리스트에서 확인 할 수 있다.

리스트의 첫 번째 항목은 모듈명이 전달되므로, 2번째 항목부터 전달 된 값을 확인 할 수 있다.

## 패키지

패키지는 모듈들을 모아 둔 특별한 **폴더** 를 뜻한다. (일반적인 폴더와는 다르다)

폴더를 패키지로 만들면 계층 구조를 가질 수 있으며, 모듈들을 해당 패키지에 모을 수 있는 역할을 한다.

패키지를 만들 때는 패키지로 사용할 폴더에 `__init__.py`파일을 넣어주면, 해당 폴더는 패키지로 취급된다. (비어있어도 무관하다)

`shop.py`와 `game.py`를 `func`패키지에 넣어본다.

```
├── func
│   ├── __init__.py
│   ├── game.py
│   └── shop.py
└── lol.py
```

패키지는 모듈과 동일하게 import할 수 있으며, 위와 같이 func패키지에 모듈들을 넣은 경우에는

`from func import game, shop`으로 기존 코드의 변경 없이 패키지에서 모듈을 가져오는 방식을 사용할 수 있다.

또는 단순히 `import func`후 `func.game`, `func.shop`을 사용하는 방식도 가능하다.

### `*` , `\_\_all\_\_`

```
패키지에 포함된 하위 패키지 및 모듈을 불러올 때, `*` 을 사용하면 해당 모듈의 모든 식별자들을 불러온다.

이 때, 각 모듈에서 자신이 import될 때 불러와질 목록을 지정하고자 한다면 `__all__` 을 정의하면 된다.

패키지 자체를 import시에 자동으로 가져오고 싶은 목록이 있다면, 패키지의 `__init__.py` 파일에 해당 항목을 import해주면 된다.

예시 : from .game import play_game을 작성해두면
from functions import play_game으로 메소드를 가져올 수 있다.
```

## 실습

1. 위 프로그램에 `friends`패키지를 만들고, `send_message`함수를 가진 `chat`모듈을 추가한다.<br>
  `send_message`는 `input`을 이용해 2개의 인자를 받으며(친구명, 메세지), 실행 시 `print`함수를 통해 메세지를 보냈다는 문구를 출력한다.
2. 프로그램을 실행했을 때, `3`을 입력하면 `send_message`함수를 실행하도록 한다.
3. 커맨드라인으로 인자를 전달받아, 모두 더한 결과를 출력하는 모듈을 만든다. 이 때, 인터프리터를 통해 실행되었을 때만 결과가 출력되도록 한다.

## 11. 클래스

### 객체지향 프로그래밍

파이썬의 모든 것은 객체이며, 객체를 사용할 때는 변수에 해당 객체 참조('Reference')시켜 사용한다. 객체는 변수와 함수를 가지며, 특별히 객체가 가진 변수와 함수는 갂각 속성(attribute)과 메서드(method)라고 부른다.

객체는 어떠한 타입, 즉 특정한 클래스의 형태를 가진 인스턴스를 나타낸다.

#### 클래스

클래스는 객체를 만들기 위한 틀이다.

예를 들어 상점을 나타내기 위한 클래스를 만든다고 해보면 아래와 같이 사용할 수 있다.

```python
class Shop:
    def __init__(self, name):
        self.name = name
```

위 코드에서, `__init__`은 클래스를 사용한 객체의 초기화 메서드이다. 객체를 생성할 때 인자를 어떻게 전달받고, 받은 인자를 이용해 어떤 객체를 생성할 지 정의할 수 있다.

위 클래스를 사용해서 객체를 생성해본다.

```python
In [1]: from class_sample import Shop
In [2]: lotteria = Shop('Lotteria')
```

이렇게 생성된 lotteria객체를 '인스턴스(instance)'라고 한다.

위 코드는 아래 순서로 동작한다.

1. Shop 클래스가 정의되었는지 찾는다.
2. Shop 클래스형 객체를 메모리에 생성한다.
3. 생성한 객체의 초기화 메서드 `__init__`을 호출한다.
4. name값을 저장하고, 만들어진 객체를 반환한다.
5. `lotteria`변수에 반환된 객체를 할당한다.

객체의 메서드를 정의할 때, 첫 번째 인수는 항상 `self`이다. `self`에는 메서드를 호출하는 객체 자신이 자동으로 전달된다.<br>
이렇게 `self`가 자동으로 호출되는 이유는 클래스의 메서드를 사용할 때 어떤 객체가 해당 메서드를 사용하고 있는지 알 수 있도록 하기 위해서이다. 또한 이렇게 하나의 메서드를 여러 객체가 공유할 수 있다.

속성이나 메서드에 접근할 때는 `객체.속성명` 또는 `객체.메서드명` 을 사용한다.

**`Shop`클래스에 `show_info`메서드를 정의해본다. 해당 메서드는**

```
상점정보 (<상점명>)
```

을 출력한다.

#### 클래스 속성

어떤 하나의 클래스로부터 생성된 객체들이 같은 값을 가지게 하고 싶을 경우, 클래스 속성(class attribute)를 사용한다.

```python
class Shop:
    description = 'Python Shop Class'
    def __init__(self, name):
        self.name = name
```

마찬가지로, 객체들에게서 각각의 인스턴스와는 별개의 공통된 메서드를 사용하게 하고 싶을 경우 클래스 메서드(class method)를 사용한다.

#### 클래스에 위치인자를 활용하는 법

클래스로 인스턴스를 만들 때 위치 인자를 사용할 수 있다. 위치 인수를 통해 리스트 언패킹을 사용하는 방법이다.<br>
매개변수에서 값을 가져오려면 args[0]처럼 사용해야 한다.

```python
class Person:
  def __init__(self, *args):
    self.name = args[0]
    self.age = args[1]
    self.address = args[2]


maria = Person(*['마리아', 20, '서울시 서초구 반포동'])
```

#### 클래스에 키워드 인자를 활용하는 법

키워드 인자를 통해 딕셔너리 언패킹을 사용할 수 있다.

```python
class Person():
  def __init__(self, **kwargs):
    self.name = kwargs['name']
    self.age = kwargs['age']
    self.address = kwargs['address']

maria1 = Person(name ='마리아', age = 20, address ='서울시 서초구 반포동')
maria2 = Person(**('name':'마리아', 'age':20, 'address':'서울시 서초구 반포동'))
```

#### 특정 속성만 허용하기

```python
class Person:
  __slots__ = ['name', 'age']  # name, age만 허용(다른 속성은 생성 제한)
```

### 메서드

#### 인스턴스 메서드

인스턴스 메서드는 첫 번째 인수로 `self`를 가진다. 인스턴스를 이용해 메서드를 호출할 때 호출한 인스턴스가 자동으로 전달되며, 전달받은 인스턴스는 상태를 확인하거나 조작하는데에 사용된다.

> **실습**<br>
> `Shop`클래스의 초기화 메서드 인자로 `shop_type`과 `address`를 추가하고, 해당 인자들을 사용해 객체의 초기값을 만들어준다

> `Shop`클래스의 인스턴스 메서드 `show_info`를 아래와 같은 결과를 출력할 수 있도록 수정해본다

```python
>>> shop.show_info()
상점 (롯데리아)
  유형: 패스트푸드
  주소: 서울시 강남구
```

> **실습**<br>
> `Shop`클래스에 `change_type`인스턴스 메서드를 추가하고, 상점유형(shop_type)을 변경할 수 있는 기능을 추가한다

> 새로운 `Shop`인스턴스를 하나 생성하고, `show_info()` 인스턴스 메서드를 사용해 본 후 `change_type`메서드를 사용해 `shop_type`을 변경시키고 다시 `show_info()`메서드를 실행해 결과가 잘 반영되었는지 확인한다

### 속성 접근 지정자 (attribute access modifier)

#### 캡슐화

객체를 구현할 때, 사용자가 반드시 알아야 할 데이터나 메서드를 제외한 부분을 은닉시켜 정해진 방법을 통해서만 객체를 조작할 수 있도록 하는 방식.

즉 객체속성 변경등이나 메서드 변경에 제한을 거는 것이다.

객체의 데이터나 메서드의 은닉 정도를 결정할 때, 속성 접근 지정자를 사용한다.

- `change_type`메서드나 `change_description`클래스 메서드를 사용하지 않고도 내부 내용을 변경할 수 있다.

속성 이름을 `__`로 시작하면, 외부에서의 접근을 제한한다. 이 경우를 `private 지정자`라고 한다.

- `shop_type`의 이름을 `__shop_type`으로 바꾸고 외부에서 직접 변경해본다.

- 실제 이름은 `_<클래스명>__<속성명>`으로 되어있다.

파이썬은 속성을 실제로 사용하지 못하도록 숨기지 않고, 네임 맹글링(name mangling)이라는 기법을 사용한다. 실제 숨기고 제한하는 것이 아니라 이름을 변경시켜서 접근을 쉽게 하지 못하도록 하는 것이다. 파이썬에서는 문법적으로 `private`데이터에 대한 접근을 막는 법을 제공하지는 않는다.<br>
이는 개발자에게 최대한 제약을 가하지 않는다는 파이썬의 철학때문이다.

**(파이썬 튜토리얼 중)**<br>
As is true for modules, classes in Python do not put an absolute barrier between definition and user, but rather rely on the politeness of the user not to "break into the definition."<br>
모듈에서도 그렇듯이, 파이썬의 클래스는 정의와 사용자 사이에 절대적인 장벽을 놓는다기보다는 "정의를 바깥에서 깨부수지 않는" 사용자의 정중함에 의존하고 있다고 할 수 있다.

### get/set속성값과 프로퍼티

파이썬에서는 지원하지 않지만, 어떤 언어들은 외부에서 접근할 수 없는 `private`객체 속성을 지원한다. 이 경우, 객체에서는 해당 속성을 읽고 쓰기 위해 `getter`, `setter`메서드를 사용해야 한다.

파이썬에서는 해당 기능을 프로퍼티(property)를 사용해 간편히 구현한다.

- 실제 getter, setter를 구현해본다.

```python
@property                - 데코레이터(내부함수)
def name(self):
    return self.__name   - ()괄호를 빼고 사용하므로, 속성처럼 접근할 수 있다.

@name.setter                - property로 감싸준 속성.setter 로 private attribute를 변경.
def name(self, new_name):
    self.__name = new_name   - setter 자체에서 attribute 변경 관련 동작을 제어할 수 있다.
    print('Set new name ({})'.format(self.__name))
```

`setter`프로퍼티를 명시하지 않으면 읽기전용이 되어 외부에서 조작할 수 없게 된다.

상속받아 사용할 수 있는 attribute로 규정하는 방법 _ (언더스코어 1개)

### 상속 (Inheritance)

거의 비슷한 기능을 수행하나, 약간의 추가적인 기능이 필요한 다른 클래스가 필요할 경우 기존의 클래스를 상속받은 새 클래스를 사용하는 형태로 문제를 해결할 수 있다.

이 때, 상속 되는 클래스를 부모(상위)클래스라고 하며, 상속을 받는 클래스는 자식(하위)클래스라고 한다.

상속을 받을때는 클래스의 정의 다음 괄호에 부모 클래스를 적어주면 된다.

```python
class Restaurant(Shop):
    pass
```

상속받은 클래스는 부모 클래스의 모든 속성과 메서드를 사용할 수 있다.

#### 메서드 오버라이드

상속받은 클래스에서, 부모 클래스의 메서드와는 다른 동작을 하도록 할 수 있다. 이 경우 부모 클래스의 메서드를 덮어씌워서 사용하도록 하며, 이 방법을 메서드 오버라이드(method override)라고 한다.

- `show_info`메서드에서 `상점`이 아닌 `식당`으로 표현되도록 메서드를 오버라이드해 새로 정의해본다.

#### 부모 클래스의 메서드를 호출 (super)

자식클래스의 메서드에서 부모 클래스에서 사용하는 메서드의 전체를 새로 쓰는것이 아닌, 부모 클래스의 메서드를 호출 후 해당 내용으로 새로운 작업을 해야 할 경우 `super()`메서드를 사용해서 부모 클래스의 메서드를 직접 호출할 수 있다.

```python
class Restaurant(Shop):
    def __init__(self, name, shop_type, address, rating):
        super().__init__(name, shop_type, address)
        self.rating = rating
```

위 코드의 경우, `super()`메서드를 사용해서 부모의 `__init__` 메서드를 호출한다.

### 다형성과 덕 타이핑

동적 바인딩 - 타입을 신경쓰지 않고 객체를 사용

파이썬은 다형성(polymorphism)을 덕 타이핑(duck typing)이라는 방식으로 구현한다.<br>
덕 타이핑은 문자 그대로

```
`오리`는 `꽥꽥`하고 우므로, `꽥꽥`하고 우는것은 `오리`로 취급한다
```

라는 방식을 사용한다.

조금 더 자세한 예를 들자면,<br>
어떠한 객체에 `울기`라는 메서드가 존재할 때, `꽥꽥`이라는 결과를 리턴한다면 해당 객체는 `오리`로 취급되며 `삐약삐약`이라는 결과를 리턴한다면 `병아리`로 취급된다.

다형성을 지원하는 프로그래밍 언어에서는 같은 이름의 함수에서 서로 다른 기능을 하는 방식으로 프로그래밍을 할 수 있다.<br>
파이썬에서는 각 객체의 타입과 전혀 상관없이 해당 객체에서 만든 같은 이름의 메서드들을 실행할 수 있다.

- User, Food, Drink와 eat을 사용해 다형성을 구현해본다.

#### 클래스 메서드

클래스 메서드는 클래스 속성에 대해 동작하는 메서드이다. 위의 인스턴스 메서드와 달리 호출 주체가 클래스이며, 첫 번째 인자도 클래스이다.<br>
만약 인스턴스가 첫 번째 인자로 주어지더라도 해당 인자의 클래스로 자동으로 바뀌어 전달된다.

클래스메서드는 `@classmethod`데코레이터를 붙여 선언하며, 첫 번째 인자의 이름은 관용적으로 `cls`를 사용한다.

상속된 클래스들에서도 사용할 수 있도록 하기 위한 것.

> **실습**<br>
> `Shop`클래스에 클래스 속성 `description`을 수정하는 클래스 메서드를 작성한다.

#### 스태틱 메서드

스태틱 메서드는 클래스 내부에 정의된 일반 함수이며, 단지 클래스나 인스턴스를 통해서 접근할 수 있을 뿐 해당 클래스나 인스턴스에 영향을 주는 것은 불가능하다.

스태틱메서드는 `@staticmethod`데코레이터를 붙여 선언한다.

상속받을 필요가 없거나 자기자신(클래스)를 반환받을 때에 사용

> 실습

1. 일상생활에서 접할 수 있는 어떠한 것에 대하여 클래스를 만들고, 최소 3개의 속성과 메서드를 만들어본다.
2. 클래스와 메서드에 `docstring`을 작성하고, 옆사람과 서로 만든 클래스를 교환한다. (gist를 사용해본다)
3. 상대방이 만든 클래스의 인스턴스를 최소 3개 만들고 인스턴스 메서드를 사용해본다.
4. 상대방이 만든 클래스의 속성을 `private`하게 지정되도록 이름을 바꾸고, `property`를 만들어 본다. `setter`가 필요없는 속성은 읽기전용으로 남겨둔다.

## 12. 정규표현식

프로그래밍에서 사용하는 일종의 형식 언어. 문자열 관련 프로그래밍에 많이 사용되며 컴파일러의 파서 부분은 이것이 반드시 들어간다.<br>
프로그램을 작성할 때는 특성상 일정한 규칙을 가진 텍스트 문자열을 사용하는 경우가 많은데, 이럴 때 정규 표현식을 사용한다.

### 패턴구분자

정규식의 패턴이 달라질 경우 그것을 구분하는 문자로, 정규식 패턴이 하나만 있을 경우에는 굳이 쓸 필요가 없지만 대부분 붙인다.<br>
보통 /를 사용한다.

### 메타 문자

정규표현식에서 일정한 의미를 가지고 쓰는 특수문자를 메타 문자라고 부른다. 여기에 쓰이는 글자가 포함된 패턴을 넣으려면 해당 글자 앖에 \를 넣어줘야 한다.

- ^ : 문자열의 시작

- $ : 문자열의 종료. 옵션에 따라 문장의 끝 또는 문서의 끝에 매치된다.

- . : 임의의 한 문자

- []: 문자 클래스. 문자 클래스 안에 들어가 있는 문자는 그 바깥에서 하나의 문자로 취급된다.

- | : or를 나타냄

- ? : 앞 문자가 없거나 하나 있음

- - : 앞 문자가 하나 이상임

- `*` : 앞 문자가 0개 이상임

- {n,m} : 앞 문자가 n개 이상 m개 이하. {0,1} 은 ?와 같은 의미다.

- {n,} : 앞 문자가 n개 이상. 위의 형태에서 m이 생략된 형태이다. {0,} 이면 * 와 같고 {1,} 이면 +와 같은 의미이다.

- () : 하나의 패턴구분자 안에 서브 패턴을 지정해서 사용할 경우 괄호로 묶어주는 방식을 사용한다.

### 패턴 변경자

패턴구분자가 끝나면 그 뒤에 쓰는 것으로, 패턴에 일괄적으로 변경을 가할 때 사용한다. 정규식 엔진에 따라 변경자의 적용 방식이 상이하므로 해당 구현의 메뉴얼을 읽어야 한다. 예를 들어 대소문자 무시 플래그의 경우 파이썬에서는 `re.compile(패턴, flags=re.I)`로 쓴다.

- i : 패턴을 대소문자 구분 없이 검사한다. 이 변경자를 사용할 경우 [a-z]로만 검사해도 자동으로 [a-zA-Z]와 같은 기능을 하게 된다. 영어가 아닌 언어(독일어, 프랑스어 등)를 다룰 때에는 버그 가능성이 있으므로 쓰지 않는 게 좋다. 대소문자라는 개념이 없는 한글, 한자, 가나문자는 이 패턴 변경자가 아무 역할도 하지 않는다.

- s : 임의의 한 문자를 가리키는 . 메타 문자에 개행 문자(\n)도 포함시키도록 한다. 이 변경자를 사용하면 .이 줄바꿈도 임의의 한 문자로 취급하여 찾는다.

- g : ^문자가 문장이 아닌 문서의 처음에, $ 문자가 문장의 끝(라인 피드 \n)이 아닌 주어진 문자열의 끝에 매치되게 변경한다. 아래 m변경자와 같다. m : 주어진 문자열에 줄바꿈이 있을 경우, 여러 줄로 취급하여 검사한다. (줄바꿈이 없다면 써도 의미가 없다.) 원래 정규표현식을 쓸 때 줄바꿈은 무시되는데, 이걸 사용하면 줄바꿈을 적용해서 검사한다. 그리고 ^은 한 줄의 시작, $는 한 줄의 끝으로 의미가 달라진다.

- x : 공백 문자를 무시한다. 단, 이스케이프(역슬래쉬하고 같이 쓸 경우)하거나 문자 클래스 안에 있을 경우에는 예외. 정규식을 조금 더 읽기 편하게 만들어준다. 그러나 이 변경자를 지원하지 않는 엔진이 많은 게 단점이다.

### 탐욕적 및 게으른 수량자

정규표현식에서는 일치하는 패턴을 찾는 횟수제한이 없어 필요이상의 상황을 연출하기도 하는데 이것은 의도적으로 수량자를 탐욕적으로 만들었기 때문이다.<br>
문법에서 말하는 탐욕적 수량자란 가능하면 가장 큰 덩어리를 찾는다는 뜻이며, 반대의 개념인 게으른 수량자는 패턴에 근접하는 최소한의 덩어리를 찾는다.

- 탐욕적 수량자 : * , +, {n,}

- 게으른 수량자 : `*?, +?, {n,}?`

파이썬에서는 표준 모듈 `re`를 사용해서 정규표현식을 사용할 수 있다.

```python
import re
result = re.match('Lux', 'Lux, the Lady of Luminosity')
```

위에서 `match`의 첫 번째 인자에는 패턴이 들어가며, 두 번째 인자에는 문자열 소스가 들어간다. `match()`는 소스와 패턴의 일치 여부를 확인하고, 일치할 경우 `Match object`를 반환한다.

매치하는 것이 없다면 None을 반환한다.

조금 복잡하거나 자주 사용되는 패턴은 미리 **컴파일** 하여 속도를 향상시킬 수 있다.

```python
pattern1 = re.compile('Lux')
```

컴파일된 패턴객체를 문자열 대신 첫 번째 인자로 사용 가능하다.

## match : 시작부터 일치하는 패턴 찾기

```python
>>> import re
>>> source = 'Lux, the Lady of Luminosity'
>>> m = re.match('Lux', source)
>>> if m:
...   print(m.group())
...
Lux
```

`match()`는 시작부분부터 일치하는 패턴만 찾기 때문에, `Lady`라는 패턴으로는 찾을 수 없다.

```python
>>> m = re.match('.*Lady', source)
>>> if m:
...   print(m.group())
...
Lux, the Lady
```

위 결과는 다음을 의미한다.

- `.`은 문자 1개를 의미
- `*`는 해당 패턴이 0회 이상 올 수 있다는 의미이다
- 따라서 `.*Lady`는 앞에 아무 문자열(또는 빈) 이후 Lady로 끝나는 패턴을 의미한다

## search : 첫 번째 일치하는 패턴 찾기

`*`패턴 없이 `Lady`만 찾을 경우, 문자열 전체에서 일치하는 부분을 찾는 `search()`를 사용한다.

```python
>>> m = re.search('Lady', source)
>>> if m:
...   print(m.group())
...
Lady
```

## findall : 일치하는 모든 패턴 찾기

```python
>>> m = re.findall('y', source)
>>> m
>>> ['y', 'y']
>>> m = re.findall('y..', source)
>>> m
['y o']
```

끝자리의 `y`는 뒤에 문자가 더 없으므로 포함되지 않으므로, `?`를 추가한다.<br>
`.`은 문자 1개를 의미하며, `?`는 0 또는 1회 반복을 사용한다. `.?`은 문자가 0 또는 1회 올 수 있음을 의미한다.

```python
>>> m = re.findall('y.?.?', source)
>>> m
['y o', 'y']
```

```
re.findall('L.{2}',source) - 뒤에 2개의 문자열이 오도록
```

```
match_list = re.finditer('L.{2}',source)
#이터레이터로 만들기.
for m in match_list:
  print(m.group())
```

```
# 패턴문자가 뭐뭐인지 확인
import string
printable = string.printable
re.findall('\w', printable)
re.findall('\d', printable)
```

## split : 패턴으로 나누기

문자열의 `split()`메서드와 비슷하지만 패턴을 사용할 수 있다.

```python
>>> m = re.split('o', source)
>>> m
['Lux, the Lady ', 'f Lumin', 'sity']
```

## sub : 패턴 대체하기

문자열의 `replace()`메서드와 비슷하지만 패턴을 사용할 수 있다.

```python
>>> m = re.sub('o', '!', source)
>>> m
'Lux, the Lady !f Lumin!sity'
```

## 정규표현식의 패턴 문자

패턴 | 문자
-- | ------------------
\d | 숫자
\D | 비숫자
\w | 문자
\W | 비문자
\s | 공백 문자
\S | 비공백 문자
\b | 단어 경계 (\w와 \W의 경계)
\B | 비단어 경계

```python
>>> import string
>>> printable = string.printable
>>> re.findall('\w', printable)
>>> re.findall('\d', printable)
```

## 정규표현식의 패턴 지정자 (Pattern specifier)

**expr** 은 정규표현식을 말한다

패턴              | 의미
--------------- | -------------------------------
abc             | 리터럴 `abc`
(expr)          | expr
expr1 \         | expr2                           | expr1 또는 expr2
`.`             | `\n`을 제외한 모든 문자
`^`             | 소스문자열의 시작
`$`             | 소스문자열의 끝
expr`?`         | 0 또는 1회의 expr
expr`*`         | 0회 이상의 최대 expr
expr`*?`        | 0회 이상의 최소 expr
expr`+`         | 1회 이상의 최대 expr
expr`+?`        | 1회 이상의 최소 expr
expr`{m}`       | m회의 expr
expr`{m,n}`     | m에서 n회의 최대 expr
expr`{m,n}?`    | m에서 n회의 최소 expr
[abc]           | a or b or c
[^abc]          | not (a or b or c)
expr1(?=expr2)  | 뒤에 expr2가 오면 expr1에 해당하는 부분
expr1(?!expr2)  | 뒤에 expr2가 오지 않으면 expr1에 해당하는 부분
(?<=expr1)expr2 | 앞에 expr1이 오면 expr2에 해당하는 부분
(?<!expr1)expr2 | 앞에 expr1이 오지 않으면 expr2에 해당하는 부분

[점프 투 파이썬 - 정규표현식 (https://wikidocs.net/4309)](https://wikidocs.net/4309)

**스토리**

Born to the prestigious Crownguards, the paragon family of Demacian service, Luxanna was destined for greatness. She grew up as the family's only daughter, and she immediately took to the advanced education and lavish parties required of families as high profile as the Crownguards. As Lux matured, it became clear that she was extraordinarily gifted. She could play tricks that made people believe they had seen things that did not actually exist. She could also hide in plain sight. Somehow, she was able to reverse engineer arcane magical spells after seeing them cast only once. She was hailed as a prodigy, drawing the affections of the Demacian government, military, and citizens alike.

As one of the youngest women to be tested by the College of Magic, she was discovered to possess a unique command over the powers of light. The young Lux viewed this as a great gift, something for her to embrace and use in the name of good. Realizing her unique skills, the Demacian military recruited and trained her in covert operations. She quickly became renowned for her daring achievements; the most dangerous of which found her deep in the chambers of the Noxian High Command. She extracted valuable inside information about the Noxus-Ionian conflict, earning her great favor with Demacians and Ionians alike. However, reconnaissance and surveillance was not for her. A light of her people, Lux's true calling was the League of Legends, where she could follow in her brother's footsteps and unleash her gifts as an inspiration for all of Demacia.

```python
story = '''Born to the prestigious Crownguards, the paragon family of Demacian service, Luxanna was destined for greatness. She grew up as the family's only daughter, and she immediately took to the advanced education and lavish parties required of families as high profile as the Crownguards. As Lux matured, it became clear that she was extraordinarily gifted. She could play tricks that made people believe they had seen things that did not actually exist. She could also hide in plain sight. Somehow, she was able to reverse engineer arcane magical spells after seeing them cast only once. She was hailed as a prodigy, drawing the affections of the Demacian government, military, and citizens alike.

As one of the youngest women to be tested by the College of Magic, she was discovered to possess a unique command over the powers of light. The young Lux viewed this as a great gift, something for her to embrace and use in the name of good. Realizing her unique skills, the Demacian military recruited and trained her in covert operations. She quickly became renowned for her daring achievements; the most dangerous of which found her deep in the chambers of the Noxian High Command. She extracted valuable inside information about the Noxus-Ionian conflict, earning her great favor with Demacians and Ionians alike. However, reconnaissance and surveillance was not for her. A light of her people, Lux's true calling was the League of Legends, where she could follow in her brother's footsteps and unleash her gifts as an inspiration for all of Demacia.'''
```

위와같이 `story`변수에 스토리 문자열을 할당한다.

```python
re.findall('Lux', story)
re.findall('Lux|her|she', story)
re.findall('[Ll]ux|[Hh]er|[Ss]he', story)
re.findall('^Born', story)
re.findall('Demacia$', story)
re.findall('was', story)
re.findall('(?<=she) was', story)
re.findall('\w+(?<!she) was', story)
re.findall('\bwas\b', story)
re.findall(r'\bwas\b', story)
```

`\`로 시작하는 패턴 문자나, 정규표현식에서 `\`를 직접 사용해야 하는 경우 문자열의 **이스케이프** 문을 사용하지 않고, 정규식 내에서 `\`로 해석됨을 나타내기 위해 앞에 `r`을 붙인다 (raw string으로 취급된다)

정규표현식의 패턴에는 항상 앞에 `r`을 붙인다고 생각하는 것이 좋다. (만약 정규표현식 내부에서 `\`를 쓰지 않을 경우, `r`을 붙임과 붙이지 않음은 같은 결과를 가져온다)

## 매칭 결과 그룹화

정규표현식 패턴중 괄호로 둘러싸인 부분이 있을 경우, 결과는 해당 괄호만의 그룹으로 저장된다.

Match객체의 `group()`함수는 매치된 전체 문자열을 리턴하며, `groups()`함수는 지정된 그룹 리스트를 리턴해준다.<br>
`group(0)`은 `group()`과 같은 동작을 하며, `group(숫자)`는 매치된 `숫자`번째의 그룹요소를 리턴해준다.

```python
s = re.search(r'\w+\w(was)', story)
s.groups()
s.group(0)
s.group(1)
```

`(?P<name>expr)` 패턴을 사용하면 매칭된 표현식 그룹에 이름을 붙여 사용할 수 있다.

```python
m = re.search(r'(?P<before>\w+)\s+(?P<was>was)\s+(?P<after>\w+)', story)
m.groups()
m.group('before')
m.group('was')
m.group('after')
```

## 최소일치와 최대일치

```python
<html><body><h1>HTML</h1></body></html>
```

위 항목을

```python
m = re.match(r'<.*>', html)
```

로 검색하면, `.*`표현식이 첫 번째 `>`에서 멈추는것이 아니라 맨 마지막 `>`까지 검색을 진행한다.<br>
`*`이나 `+`에 최소일치인 `?`를 붙여주면, 표현식 다음부분에 해당하는 문자열이 처음 나왔을 때 그 부분까지만 일치시키고 검색을 마친다.

## 실습

아래 실습들은 위의 `story`변수 문자열을 소스로 사용한다.

1. `{m}`패턴지정자를 사용해서 `a`로 시작하는 4글자 단어를 전부 찾는다.

```python

import re

story =''' Born to the prestigious Crownguards, the paragon family of Demacian service, Luxanna was destined for greatness. She grew up as the family's only daughter, and she immediately took to the advanced education and lavish parties required of families as high profile as the Crownguards. As Lux matured, it became clear that she was extraordinarily gifted. She could play tricks that made people believe they had seen things that did not actually exist. She could also hide in plain sight. Somehow, she was able to reverse engineer arcane magical spells after seeing them cast only once. She was hailed as a prodigy, drawing the affections of the Demacian government, military, and citizens alike.

As one of the youngest women to be tested by the College of Magic, she was discovered to possess a unique command over the powers of light. The young Lux viewed this as a great gift, something for her to embrace and use in the name of good. Realizing her unique skills, the Demacian military recruited and trained her in covert operations. She quickly became renowned for her daring achievements; the most dangerous of which found her deep in the chambers of the Noxian High Command. She extracted valuable inside information about the Noxus-Ionian conflict, earning her great favor with Demacians and Ionians alike. However, reconnaissance and surveillance was not for her. A light of her people, Lux's true calling was the League of Legends, where she could follow in her brother's footsteps and unleash her gifts as an inspiration for all of Demacia. '''

s = re.findall(r'\ba\w{3}\b')
```

1. r로 끝나는 모든 단어를 찾는다.

  ```python
  s = re.findall(r'\b\w*r\b',story)
  ```

2. a,b,c,d,e중 아무 문자나 3번 연속으로 들어간 단어를 찾는다.

  > ex) b[eca]me

```python

s = re.findall(r'\b\w+\B[a-e][a-e][a-e]\B+\w\b')

s = re.findall(r'\w*[abcde]{3}\w*')
```

1. `re.sub`를 사용해서 `,`로 구분된 앞/뒤 단어에 대해 앞단어는 대문자화 시키고, 뒷단어는 대괄호로 감싼다. 이 과정에서, 각각의 앞/뒤에 `before`, `after`그룹 이름을 사용한다.

```
s = re.sub(r'\b\w',)


s = re.findall(r'(?P<before>\w)\s*,\s*(?P<after>\w+)',story)

p = re.compile(r'(?P<before>\w)\s*,\s*(?P<after>\w+)',re.UNICODE)

re.sub(p,r'\g<before>\g<after>',story)

def m_capitalize(m):
  return '{}'.format(m.group(before))

def m_big(m):
  return '[{}]'.format(m.group(after)

def m_func(m):
  return '{}{}'.format(m.group(before).capitalize(). m.groups().replace(m.group(1),'')
```

## 예외처리

오류가 발생하면 프로그램은 에러를 출력하며 강제종료되거나, 원하지 않는 동작을 한다.

이러한 오류를 안전하게 처리하고, 바로 강제종료 되지 않고 오류 발생 후 처리할 루틴을 실행하고자 할 때 예외처리를 사용한다.

### 가장 기본적인 형태

```python
try:
    시도할 코드
except:
    에러가 발생했을 경우 실행할 코드
```

- 리스트의 범위를 넘어간 에러를 테스트해본다.

```python
l = list('abcd')

print('program start')
try:
    print('before l[5]')
    #l[3]에 접근했을 때 어느부분까지 코드가 실행되는지 확인
    l[5]
    print('after l[5]')
except:
    print('l[5] exception')

print('progarm terminate')


l = list('abcd')
d = dict(name = 'Lux', champion_type = 'Magician')

try:
    d['Sona']  #- exception이 발생하는 구문까지 가다가 except로 넘어감.
    l[5]
except IndexError:
    print('l[5] excepttion')
except KeyError:
    print('d['Sona'] excepttion')

print('program terminate')
```


### 여러가지 예외를 구분할 경우

```python
try:
    시도할 코드
except <예외 클래스1>:
    에러클래스 1에 해당할 때 실행할 코드
except <예외 클래스2>:
    ...
except <예외 클래스3>:
    ...
```

- 리스트의 범위를 넘어간 경우, `IndexError`를 명시적으로 처리해본다
- 딕셔너리의 키가 없는 경우, `KeyError`를 명시적으로 처리해본다

### 예외사항을 변수로 사용할 경우

```python
try:
    시도할 코드
except <예외클래스> as <변수명>:
    <변수명>을 사용한 코드
```

- 위 예외에서 변수로 전달된 예외객체를 출력해본다

```python
except IndexError as I:
    import Traceback
    print(I)
    print(Traceback.format_exc()) #- 정황힉 어떤 에러가 어디서 났는지 확인하는 방법.

```

## try ~ else

`else`문은 `try`이후 예외가 발생하지 않을 경우 실행된다.

```python
try:
    시도할 코드
except:
    예외 발생시 실행 코드
else:
    예외가 발생하지 않았을 시 실행할 코드
```

```python
'''
while문 내에 try 구문에서 input을 이용해 숫자값을 입력받음
입력받는 숫자값에 해당하는 l[index]를 참조하고, IndexError일 경우 다시 숫자값 입력
IndexError가 나지 않으면 while문 종료
'''
l = ['abcd']


while True:
    try:
      index=int(input('숫자를 입력하세요: '))
      print('입력한 숫자: {}'.format(index))
      print(l[index])
    except IndexError as IE:
      import Traceback
      print('Index Error!')
      print(Traceback.format_exc())
    except ValueError:
      print('숫자만 입력하세요')
    else:
      print('장비를 정지합니다')
      break


```

## try ~ finally

`finally`문은 `try`이후 예외가 발생하건, 하지않건 무조건 마지막에 실행된다.

```
루프 회수를 센다던가 꼭 실행해야 하는 코드를 삽입
```

## 예외 발생시키기

예외를 발생시킬때는 `raise`구문을 사용한다.

## 예외 만들기

내장 클래스 `Exception`을 상속받아 커스텀 예외를 만들 수 있다. 초기화 메서드에서 예외에서 처리할 데이터를 받고, `print`문으로 사용되고 싶다면 `__str__`메서드를 오버라이드 해준다.

```python
'''
1. 정규표현식으로 검사했을 때 패턴이 없을 경우 발생할 NotMatchedException을 사용자 정의
    1-1. Exception을 상속
    1-2. __init__ 메소드에서 패턴문자열과 소스문자열을 매개변수로 사용
    1-3. __str__ 메소드는 __init__에서 받은 "패턴문자열"이 "소스문자열"에 없음을 출력
2. 패턴문자열과 소스문자열을 매개변수로 갖는 search_from_source함수를 정의
    만약 re.search로 소스문자열에서 패턴을 검색했을 때 MatchObject를 찾지 못하면,
    raise NotMatchedException(패턴문자열, 소스문자열)을 발생시킴

3. try-except 구문에서 위 함수를 실행, 예외를 발생시키고 except 구문에서 해당 예외를 받을
    수 있도록 구현
'''
import re
# 패턴과 소스를 생성자 매개변수로 갖는 Exception 클래스 정의
class NotMatchedException(Exception):
    def __init__(self,pattern, source):
        pass
    #print(obj)했을 때 출력될 내용
    def __str__(self):
        return 'Pattern "{}" is not matched in source "{}"'.format(self.Pattern,self.source)
#패턴과 소스매개변수를 받아 re.search로 소스에서 패턴을 검색, 찾지 못하면 NotMatchedException 발생
def search_from_source(p,s):
        m = re.search(p, s)
        if not m:
            raise NotMatchedException(p,s)
        return m

source_string = 'Lux, the Lady of Luminosity'

pattern_string = r'L\w{5}\b'

try:
    result = search_from_source(pattern_string, source_string)
    print('result')
except NotMatchedException as e:
    print(e)

print('Search Result:', result)

```


## 파일 다루기

프로그램이 실행되는 동안 데이터는 휘발성 기억장치인 메모리(RAM)에 저장된다. 작업중인 데이터를 저장하거나, 이미 저장되어있는 데이터를 불러오기 위해서는 하드디스크나 SSD에 파일을 쓰거나 읽는 과정이 필요하다.

## 파일 열기

```python
변수 = open(파일명, 모드)
```

내장함수 `open()`을 사용하며, 파일명은 파일의 경로를 나타낸다.

-

**모드의 첫 번째 글자**

모드|설명
---|---
r|읽기
w|쓰기 (파일이 이미 존재할 경우 덮어쓴다)
x|쓰기 (단, 파일이 존재하지 않을 경우에만)
a|추가 (파일이 존재할 경우 파일의 끝부터 쓴다)

**모드의 두 번째 글자**

모드|설명
---|---
t 또는 없음|텍스트타입
b|이진데이터 타입


**이진데이터**  
이진형식(0과 1)로 이루어진 텍스트를 제외한 데이터를 말함.  
텍스트 역시 이진데이터의 일종이지만, 데이터의 구조가 인코딩과 개행문자 등 텍스트 형태로 바로 사용할 수 있게 되어있다는 차이가 있다.


파일을 열고 사용한 뒤에는 파일을 닫아야한다.

## 파일 쓰기: write()

```python
>>> skills = '''Illumination
... Light Binding
... Prismatic Barrier
... Lucent Singularity
... Final Spark'''
>>>
>>> len(skills)
75
```

```python
>>> f = open('skills.txt', 'wt')
>>> f.write(skills)
75
>>> f.close()
```

`skills.txt`파일에 내용을 쓴다.

만약 문자열이 클 경우, 일정 단위로 나누어서 파일에 쓰는 방식을 사용한다.

```python
>>> f = open('skills.txt', 'wt')
>>> size = len(skills)
>>> offset = 0
>>> chunk = 30
>>> while True:
...   if offset > size:
...     break
...   f.write(skills[offset:offset+chunk])
...   offset += chunk
...
30
30
15
```

덮어쓰기를 방지하려면 `wt`대신 `xt`를 사용해서 이미 존재하는 파일은 쓸 수 없도록 처리한다.

```python
>>> try:
...   f = open('skills.txt', 'xt')
...   f.write('Other contents')
... except FileExistsError:
...   print('skills.txt exists')
...
skills.txt exists
```

## 텍스트파일 전체 읽기: read()

`read()`함수는 전체 파일을 한 번에 가져오므로, 메모리 사용에 유의해야한다.

```python
>>> f = open('skills.txt', 'rt')
>>> skills = f.read()
>>> f.close()
>>> len(skills)
75
```

한 번에 읽을 크기를 제한하고 싶다면, 인자로 최대 문자수를 입력해준다.

```python
>>> f = open('skills.txt', 'rt')
>>> chunk = 30
>>> while True:
...   part = f.read(chunk)
...   if not part:
...     break
...   skills += part
...
>>> f.close()
>>> len(skills)
75
```

파일을 전부 읽으면 빈 문자열이 리턴되고, `if`문에서 `False`로 판단하여 루프가 끝난다.

## 텍스트파일 줄 단위 읽기: readline()

```python
>>> skills = ''
>>> f = open('skills.txt', 'rt')
>>> while True:
...   line = f.readline()
...   if not line:
...     break
...   skills += line
...
>>> f.close()
>>> len(skills)
75
```
파일을 라인단위로 읽어 문자열에 저장한다.

빈 라인(`\n`)은 길이가 1이며, 파일의 끝에서만 완전히 빈 문자열 (`''`)을 리턴한다.

## 이터레이터를 사용한 텍스트 파일 읽기

```python
>>> skills = ''
>>> f = open('skills.txt', 'rt')
>>> for line in f:
...   skills += line
...
>>> f.close()
>>> len(skills)
75
```

`readline()`을 호출한 것과 같은 결과를 보인다.

## 텍스트파일을 줄 단위 문자열 리스트로 리턴: readlines()

```python
>>> f = open('skills.txt', 'rt')
>>> lines = f.readlines()
>>> f.close()
>>> for line in lines:
...   print(line)
...
Illumination

Light Binding

Prismatic Barrier

Lucent Singularity

Final Spark
>>> for line in lines:
...   print(line, end='')
...
Illumination
Light Binding
Prismatic Barrier
Lucent Singularity
Final Spark>>>
```

각 줄에 줄바꿈(`\n`)문자가 있으므로 `print()`함수에 `end`인자를 주어 줄바꿈을 없앨 수 있다.

마지막 라인에는 줄바꿈이 없으므로 인터프리터 프롬프트가 같은 줄에 표시된다.

## 자동으로 파일 닫기: with

연 파일을 닫지 않을 경우, 파이썬에서는 해당 파일이 더 이상 사용되지 않을 때 파일을 자동으로 닫아준다.

다만 메인프로그램이나 오랫동안 동작하는 함수에서 파일을 열 경우, 명시적으로 닫아주지 않을 경우 문제가 발생한다.

```
with 표현식 as 변수
```
위의 구문을 사용하면, `with`문 내부에서 파일을 사용한 후 구문이 종료되면 자동으로 파일을 닫아주므로 프로그래밍 단계에서 일일이 파일을 닫아주는 부분에 신경쓰지 않아도 된다.

```python
>>> with open('skills.txt', 'wt') as f:
...   f.write(skills)
```

## 이진데이터 다루기

쓰거나 읽을 때, `t`대신 `b`인자를 사용하면 된다.


## 웹 크롤러 만들기

정규표현식을 이용해 html파일을 직접 분석할 수 있다.

```python

import re

f = open('sample.txt','rt')
source = f.read()

re.compile(r'.*', re.DOTALL) #- .과 개행문자를 포함해서 검색
# <td class="title">내용</td>까지의 목록들을 정규표현식으로 찾기
p=re.compile(r'(<td.*?class="title">)(.*?)(</td>)',re.DOTALL)

# 꺾쇠 사이의 공백을 없애기
# re.sub
# group 사용.
result - re.findall(p,source)
for index, item in enumerate(s):
    print('== index %s ==' % index

    # ><사이의 공백을 모두 없앰
    cur_strip_item = re.sub(r'>\s*?<', '><', item, flags=re.DOTALL)
    print(cur_strip_item)

#a태그 내부의 내용을 출력.

    cur_title = re.sub(r'.*?<a.*?(.*?)</a>.*',r'\g<1>', cur_strip_item)
    print(cur_title)



def find_tag(tag_name, class_name, source):
    p = re.compile('r<{tag_name} class="{class_name}".*?>.*?</{tag_name}>'.format(tag_name=tag_name,class_name=class_name))
    return
```

과제: bs4를 이용해 웹 크롤링하기.
