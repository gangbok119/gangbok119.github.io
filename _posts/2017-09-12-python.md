---
layout: post
title: Python 정리정돈
tags: [개발공부]
description: >
  Python 문법 정리입니다.
author: Yamoong
---

# Python

## 1.  pyenv, virtualenv, iPython 설치 및 설정


### pyenv
pyenv는 프로젝트별로 파이썬 버전을 관리할 수 있도록 도와주는 라이브러리이다.
여러 프로젝트를 동시에 진행하다보면, 프로젝트마다 사용하는 버전이 달라질 수 있다.
이러한 파이썬 버전간의 충돌을 방지하기 위해 사용한다.

###  virtualenv
파이썬 개발환경을 프로젝트별로 분리해서 관리할 수 있게 해주는 라이브러리이다.
위의 pyenv와 다른 점은, pyenv는 파이썬의 버전을 관리해주는 것이며, virtualenv는
파이썬 패키지 설치 환경을 따로 관리하는 가상 환경이다.

###  pyenv-virtualenv


### pyenv 설치

`curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash`


### pyenv 가상환경 생성

`pyenv viertualenv <version> <env_name>`

> `pyenv virtualenv 3.6.2 fc-python` 입력

사용할 폴더로 이동

해당 폴더에서 가상환경 지정

`pyenv local fc-python`

가상환경 지우기

`pyenv uninstall <env_name>`

```
각종 용어

리터럴
변하지 않은 고정된 데이터 자체의 표현

- 5 (정수형 데이터)
- "Fastcampus" (문자열 데이터)
- 1.4937 (부동소수점 데이터)

표현식(expression)
값을 의미하는 표현 또는 값을 반환하는 표현

'''Python
>>> sec = 60
>>> 365*24*sec - 표현식
5256600        - 정수 525600의 리터럴 값
'''

구문(statement)
값의 의미를 지니지 않으며, 어떠한 목적을 수행하는 코드

'''Python
>>> for char in '안녕하세요':  - 구문(제어문)
...   print(char)
...
안
녕
하
세
요
```


## 2. 변수

파이썬은 모든 것이 객체로 이루어져 있다.
객체는 데이터의 형태를 결정해주는 타입으로, 파이썬에서는 객체의 타입을 바꿀 수 없다.

프로그래머는 변수를 선언하고 사용하는 형태로 컴퓨터의 메모리에 값을 항당하고, 참조할 수 있다.
파이썬에서는 값을 할당할 때 `=` 기호를 사용한다.

>일반적으로, 프로그래밍 언어에서 같다(Equal)의 의미는 =가 아닌 ==이 담당한다.

```
var1 =100
var2 =var1
var3 =var1

id(var1)
9288864
id(var2)
9288864
id(var3)
9288864

var1=101 할당 이후

var2와 var3는 여전히 100의 주소를 가리키고 있음을 알 수 있음.
```

변수는 단지 이름일 뿐이며, 그 자체가 어떠한 값을 갖는 것이 아니다.
변수는 단순히 해당 객체를 **참조** 하는 역할을 한다.

+ 변수의 타입 확인

내장함수 *Type* 사용

`<class 'int'>` , `<class 'str'>`

위의 출력에서 클래스는 객체의 타입(정의)를 나타낸다.

+ 변수의 이름 제한

사용가능한 문자
소문자
대문자
숫자
`언더스코어(_)`

이름은 숫자로 시작할 수 없으며, 언더스코어로 시작하는 변수명은 특별한 처리방법을 따르므로 일반적으로 사용하지 않는다.

+ 예약어

```
False, class, finally, is, return,
None, continue, for, lambda, try,
True, def, from, nonlocal, while,
and, del, global, not, with,
as, elif, if, or, yield,
assert, else, import, pass,
break, except, in, raise
```

+ 변수의 입력과 출력

입력은 내장함수 **input** 사용

```
>>> var = input()
```

입력받는 프롬프트를 띄우려고 할 경우, `input`에 문자열을 인자로 전달해준다.

```
>>> var = input('숫자를 입력해주세요 : ')
```

출력은 내장함수 **print** 사용

```
>>> print(var)
```

## 3, 내장데이터 타입(숫자)

+ 수학 연산자

연산자|설명|예|결과
---|---|---|---|
\+	| 더하기		| 32 + 7	| 39
\-	| 빼기		| 82 - 2	| 80
\*	| 곱하기		| 3 * 7	| 21
/	| 나누기		| 7 / 2	| 3.5
//	| 정수나누기	| 7 // 2	| 3
%	| 나머지		| 7 % 3	| 1
**	| 지수		| 2**10	| 1024

+ 산술 연산자 결합

a에 100을 할당하고, 3을 뺀 결과를 다시 a에 할당한다.

```
>>> a = 100
>>> result = a - 3
>>> a = result
>>> print(a)
97
```

위 코드는 아래와 같이 줄여서 사용가능하다.

```
>>> a = 100
>>> a = a - 3
>>> print(a)
97
```

위 코드는 산술 연산자 결합으로 아래와 같이 사용가능하다.

```
>>> a = 100
>>> a -= 3
>>> print(a)
97
```

+ 우선순위

우선순위 규칙이 적용되지만, 가독성에 문제가 있을 경우 괄호로 묶어준다.

+ 진수(base)

기본적으로 숫자형 데이터는 10진수로 간주되지만, 파이썬에서는 2진수, 8진수, 16진수를 표현할 수 있다.

- 2진수(binary): **0b** 또는 **0B** 로 시작
- 8진수(octal): **0o** 또는 **0O** 로 시작
- 16진수(hex): **0x** 또는 **0X** 로 시작 - 0123456789abcdef

## 5.4. 문자열

> 파썬3에서는 문자열에서 기본적으로 유니코드(Unicode)를 사용하며, 불변(immutable)하다.

+ 문자열 표현

**작은 따옴표 또는 큰 따옴표**

```
>>> '패스트캠퍼스'
'패스트캠퍼스'
>>> "패스트캠퍼스"
'패스트캠퍼스'
```

작은 따옴표 또는 큰 따옴표를 사용했을 때, 사용하지 않은 인용 부호는 문자열 내부에서 사용 가능하다.

```
>>> '패스트캠퍼스 "웹 프로그래밍 스쿨"'
'패스트캠퍼스 "웹 프로그래밍 스쿨"'
```

**세 개의 작은 따옴표 또는 큰 따옴표**
여러줄에 걸친 문자열을 나타낼 때 사용

```
>>> '''소환사 여러분.
... 7.1 패치를 소개합니다.'''
```

+ 문자열 더하기

```
>>> notice = ''
>>> notice += '공지사항'
```

+ 형변환

내장함수 **str** 을 사용

```
>>> str(147)
'147'
```

문자열을 제외한 객체를 'print' 함수로 호출하면, 내부적으로 'str'함수를 사용한 결과를 나타내준다.

+ 스케이프 문자

특수문자, 또는 특별한 역할을 하는 의미를 나타내는 문자를 뜻한다.

이스케이프 문자|설명
---|---
\a	| 비프음 발생
\t	| 탭(tab)
\n	| 줄바꿈
\\	| \\(역슬래시) 입력
\\'	| 작은따옴표(') 입력
\\"	| 큰따옴표(") 입력

+ 인덱스 연산

문자열에서 문자를 추출하기 위해 대괄호와 오프셋을 지정할 수 있다.
가장 왼쪽은 0이며, 가장 오른쪽은 -1로 시작한다.

```
>>> lux = '빛으로 강타해요!'
>>> lux[0]
'빛'
>>> lux[-1]  - 가장 마지막 인덱스 -1 부터 거꾸로
'!'
>>> lux[50]  - 인덱스 숫자를 초과해 입력하면 오류
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
```

문자열은 불변이므로 인덱싱한 부분에 새 값을 대입할 수 없다.

```
>>> lux[0] = '손'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
```

+ 슬라이스 연산

**[start:end:step]** 형식을 사용한다.

- [\:]
	- 처음부터 끝까지
- [start\:]
	- start오프셋부터 마지막까지
- [:end]
	- 처음부터 end오프셋까지
- [start:end]
	- start오프셋부터 end오프셋까지
- [6.art\:end\:step]
	- start오프셋부터 end오프셋까지, step만큼씩 뛰어넘은 부분

+ 길이

내장함수 **len** 을 사용

+ 문자열 나누기(split)

문자열의 내장함수 **split** 을 사용

**split** 함수에 인자로 주어진 **구분자** 를 기준으로 하나의 문자열을 리스트 형태로 반환해준다.

```Python
>>> girlsday = "민아,유라,소진,혜리"
>>> girlsday.split(',')
['민아,' '유라', '소진', '혜리']
```

**split** 함수에 인자를 주지 않을 경우, 공백문자를 구분자로 사용한다.

+ 문자열 결합(join)

**split** 함수와 반대의 역할을 한다.
문자열 리스트를 하나의 문자열로 결합해주며, 각 문자열을 결합해줄 구분자 문자열을 지정한 후 **join** 함수를 사용해준다.

```Python
>>> girlsday_list = girlsday.split(',')
>>> girlsday_str = ', '.join(girlsday_list)
>>> print(girlsday_str)
민아, 유라, 소진, 혜리
```

+ 대소문자 다루기

```python
>>> lux = 'lux, the Lady of Luminosity'
>>> lux.capitalize() - 첫 글자를 대문자로
'Lux, the lady of luminosity'
>>> lux.title() - 각 단어의 첫 글자를 대문자로
'Lux, The Lady Of Luminosity'
>>> lux.upper() - 모든 글자를 대문자로
'LUX, THE LADY OF LUMINOSITY'
>>> lux.lower() - 모든 글자를 소문자로
'lux, the lady of luminosity'
>>> lux.swapcase() - 대문자는 소문자로, 소문자는 대문자로
'LUX, THE lADY OF lUMINOSITY'
```

+ 공식문서

[Text Sequence - String Methods](https://docs.python.org/3/library/stdtypes.html#string-methods)

## 5. 문자열 포맷

### 옛 스타일(%)

```
string % data
```

변환타입|설명
---|---
%s	|	문자열
%d	|	10진수
%x	|	16진수
%o	|	8진수
%f	|	10진 부동소수점수
%e	|	지수로 나타낸 부동소수점수
%g	|	10진 부동소수점수 혹은 지수로 나타낸 부동소수점수
%%	|	리터럴 %

```python
>>> '%s' % 42
'42'
>>> '%d x %d : %d' % (3, 4, 12)
'3 x 4 : 12'
```

+ 정렬

```
%[정렬기준(-,없음)[전체글자수].[문자길이 또는 소수점 이후 문자길이][변환타입]]
```

```python
>>> d = 37
>>> f = 3.14
>>> s = 'Fastcampus'
>>> '%d %f %s' % (d, f, s)
'37 3.140000 Fastcampus'
>>> '%10d %10f %10s' % (d, f, s)
'        37   3.140000 Fastcampus'
>>> '%14d %14f %14s' % (d, f, s)
'            37       3.140000     Fastcampus'
>>> '%-14d %-14f %-14s' % (d, f, s)
'37             3.140000       Fastcampus    '
>>> '%-14.3d %-14.3f %-14.3s' % (d, f, s)
'037            3.140          Fas           '
```

### 새 스타일 ({}, format)

  ```
{}.format(변수)
```

```python
# 기본형태
>>> '{} {} {}'.format(d, f, s)
'37 3.14 Fastcampus'

# 각 인자의 순서를 지정
>>> '{1} {2} {0}'.format(d, f, s)
'3.14 Fastcampus 37'

# 각 인자에 이름을 지정
>>> '{d} {f} {s}'.format(d=50, f=1.432, s='WPS')
'50 1.432 WPS'

# 딕셔너리로부터 변수 할당
>>> dict = {'d': d, 'f': f, 's': s}
>>> '{0[d]} {0[f]} {0[s]} {1}'.format(dict, 'WPS')
'37 3.14 Fastcampus WPS'

# 타입 지정자 입력
>>> '{:d} {:f} {:s}'.format(d, f, s)
'37 3.140000 Fastcampus'

# 이름과 타입지정자를 모두 사용
>>> '{digit:d} {float:f} {string:s}'.format(digit=700, float=1.4323, string='Welcome')
'700 1.432300 Welcome'

# 필드길이 10, 우측정렬
>>> '{:10d}'.format(d)
'        37'
>>> '{:>10d}'.format(d)
'        37'

# 필드길이 10, 좌측정렬
>>> '{:<10d}'.format(d)
'37        '

# 필드길이 10, 가운데 정렬
>>> '{:^10d}'.format(d)
'    37    '

# 필드길이 10, 가운데 정렬, 빈 공간은 ~로 채움
>>> '{:~^10d}'.format(d)
'~~~~37~~~~'
```

## 6. 시퀀스 타입

파이썬에 내장된 시퀀스 타입에는 문자열, 리스트, 튜플이 있다.  
문자열은 인용부호(작은따옴표, 큰따옴표)를 사용하며, 리스트는 대괄호[], 튜플은 괄호()를 사용하여 나타낸다.  
시퀀스 타입의 객체는 인덱스 연산을 통해 내부 항목에 접근 할 수 있다.

### 리스트

리스트는 순차적인 데이터를 나타내는 데 유용하며, 문자열과는 달리 내부 항목을 변경할 수 있다.

+ 리스트의 생성

```
>>> empty_list1 = []
>>> empty_list2 = list()
>>> sample_list = ['a', 'b', 'c', 'd']
>>> sample_list2 = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
```

+ 다른 데이터를 리스트로 변환

**list** 함수를 사용

```python
>>> list('League of legends')
['L', 'e', 'a', 'g', 'u', 'e', ' ', 'o', 'f', ' ', 'l', 'e', 'g', 'e', 'n', 'd', 's']
```

이 외에도 리스트로 변환 가능한 타입에서 사용가능하다.

+ 인덱스 연산

문자열과 같이 인덱스 형태로 내부 인자들을 연산할 수 있다.

+ 내부항목 변경

리스트는 문자열과 다르게 내부항목을 변경할 수 있다.
해당 인덱스의 인자의 내용을 할당할 수 있다.

+ 슬라이스 연산

+ 리스트 항목 추가 (append)

```python
>>> sample_list.append('e')
>>> sample_list
['a', 'b', 'c', 'd', 'e']
```

+ 리스트 병합 (extend, +=)

```
>>> fruits = ['apple', 'banana', 'melon']
>>> colors = ['red', 'green', 'blue']
>>> fruits.extend(colors)
>>> fruits
['apple', 'banana', 'melon', 'red', 'green', 'blue']
```

```
>>> fruits = ['apple', 'banana', 'melon']
>>> colors = ['red', 'green', 'blue']
>>> fruits += colors
>>> fruits
['apple', 'banana', 'melon', 'red', 'green', 'blue']
```

**extend** 대신 **append** 를 사용하면?

리스트에 리스트를 인자로 append메소드를 사용하면, 리스트 자체가 인자로 추가되므로, 항목들을 추가하려면
extend 메소드를 사용해야 한다.

+ 특정 위치에 리스트 항목 추가 (insert)

리스트 함수 **insert(offset)** 을 사용  

- fruits리스트의 1번째 위치에 'mango'를 추가해보자
- fruits리스트의 100번째 위치에 'pineapple'을 추가해보자

`fruits.insert(1, mango)`

+ 특정 위치 리스트 항목 삭제 (del)

파이썬 구문 **del** 을 사용

> del은 리스트 함수가 아닌, 파이썬 구문이므로 `del <리스트>[오프셋]` 형식을 사용한다.

```
>>> del fruits[0]
```

+ 값으로 리스트 항목 삭제 (remove)

```
>>> fruits.remove('mango')
```

+ 리스트 항목 추출 후 삭제 (pop)

```
>>> fruits.pop()
>>> fruits.pop(-3)
```
pop은 삭제하면서 해당 값을 반환한다.

+ 값으로 리스트 항목 오프셋 찾기 (index)

```
>>> fruits.index('red')
```

+ 존재여부 확인 (in)

```
>>> 'red' in fruits
True
```

+ 값 세기 (count)

```
>>> fruits.append('red')
>>> fruits.append('red')
>>> fruits.count('red')
3
```

+ 정렬하기 (sort, sorted)

- sort는 리스트 자체를 정렬
- sorted는 리스트의 정렬 복사본을 반환

+ 리스트 복사 (copy)

- copy함수
- list함수
- 슬라이스 연산[:]

list2 = list1

이 상태에서 list1의 값을 변경하면 list2도 자동으로 변경된다. 두 리스트가 가리키는 id값이 같기 때문이다.
그러므로 값 자체를 복사하기 위해서는 해당 메소드들을 사용해야 한다.

### 튜플

튜플은 리스트와 비슷하나, 정의 후 내부 항목의 삭제나 수정이 불가능하다.

+ 튜플 생성

```python
>>> empty_tuple = ()
```

```python
>>> colors = 'red',
>>> color = 'red' - 문자열 생성임.
>>> fruits = 'apple', 'banana'
```

튜플을 정의할 때는 괄호가 없어도 무관하나, 괄호로 묶는것이 좀 더 튜플임을 구분하기 좋다.  
또한, 튜플의 요소가 1개일 때는 요소의 뒤에 쉼표(,)를 붙여야 한다.

+ 튜플 언패킹

```python
>>> f1, f2 = fruits
```

값의 교환

+ 형 변환

**tuple** 함수를 사용 (튜플 생성에는 사용 불가능)

리스트를 튜플로 변환

+ 튜플을 사용하는 이유

- 리스트보다 적은 메모리 사용
- 정의후에는 변하지 않는 내부 값

### 딕셔너리(dictionary)

Key-Value형태로 항목을 가지는 자료구조.


+ 딕셔너리 생성

```python
>>> empty_dict1 = {}
>>> empty_dict2 = dict()
>>> champion_dict = {
... 'Lux': 'the Lady of Luminosity',
... 'Ahri': 'the Nine-Tailed Fox',
... 'Ezreal': 'the Prodigal Explorer',
... 'Teemo': 'the Swift Scout',
... }
```

+ 형변환

**dict** 함수를 사용, 두 값의 시퀀스(리스트 또는 튜플)을 딕셔너리로 변환 한다.

```python
>>> sample = [[1,2], [3,4], [5,6]]
>>> dict(sample)
{1: 2, 3: 4, 5: 6}
```

+ 항목 찾기/추가/변경 [key]

```
>>> champion_dict['Lux']
'the Lady of Luminosity'
>>> champion_dict['Sona'] = 'Maven of the Strings'
>>> champion_dict['Lux'] = 'Demacia'
```

+ 결합 (update)

```
>>> item_dict = {
... 'Doran\'s Ring': 400,
... 'Doran\'s Blade': 450,
... 'Doran\'s Shield': 450,
... }
>>> com_dict = {}
>>> com_dict.update(champion_dict)
>>> com_dict.update(item_dict)
>>> com_dict
```

서로 같은 키가 있을 경우, update에 주어진 딕셔너리의 값이 할당된다.


+ 삭제 (del)

```
>>> del com_dict['Doran\'s Blade']
>>> del com_dict['Doran\'s Ring']
>>> del com_dict['Doran\'s Shield']
```

+ 전체 삭제 (clear)

전체 항목을 삭제


+ in으로 키 검색

True/False를 반환한다.


+ 키 또는 값 얻기

**keys()**  
모든 키 얻기

**values()**  
모든 값 얻기

**items()**  
모든 키-값 얻기 (튜플로 반환)

+ 복사

**copy()**  



### 셋(Set)

셋은 키만 있는 딕셔너리와 같으며, 중복된 값이 존재할 수 없다.


+ 셋 생성

```python
>>> empty_set = set()
>>> champions = {'lux', 'ahri', 'ezreal'}
```

+ 형변환

문자열, 리스트, 튜플, 딕셔너리를 셋으로 변환할 수 있으며, 중복된 값이 사라진다.

```
>>> set('ezreal')
{'e', 'z', 'a', 'l', 'r'}
```

```
>>> set(champion_dict)
{'Ahri', 'Lux', 'Ezreal', 'Sona', 'Teemo'}
```
딕셔너리는 키만 남는다.

+ 집합 연산

연산자|설명
---|---
`|`	|	합집합(Union)
&	|	교집합(Intersection)
\-	|	차집합(Difference)
^	|	대칭차집합(Exclusive)
<=	|	부분집합(Subset)
<	|	진부분집합(Proper subset)
\>=	|	상위집합(Superset)
\>	|	진상위집합(Proper superset)

```
>>> A = {1,2,3,4,5}
>>> B = {4,5,6,7,8,9}
>>> C = {4,5,6}
>>> A|B
>>> A&B
>>> A-B
>>> B-A
>>> A^B
>>> A <= B
>>> C <= B
>>> C < B
>>> B <= B
>>> B < B
```

## 7. 제어문

### if, elif, else(조건문)

if와 else는 조건이 참인지 거짓인지 판단하는 파이썬 선언문(statement)이며, elif는 else 내의 if를 중첩해야 할 때 사용한다.

```
if 조건:
  조건이 참일 경우

조건이 참이 아니면 무시
```

```
if 조건:
  조건이 참일 경우
else:
  조건이 거짓일 경우
```

```
if 조건1:
  조건1이 참일 경우
else:
  조건1이 거짓일 경우

  if 조건2:
    조건1은 거짓이나, 조건2는 참일 경우
  else:
    조건1,2가 모두 거짓일 경우
```

위 코드는 아래와 같이 `elif`로 줄여쓸 수 있다.

```
if 조건1:
  조건1이 참일 경우
elif 조건2:
  조건1은 거짓이나, 조건2가 참일 경우
else:
  조건1,2가 모두 거짓일 경우
```

+ 조건표현식

```
참일 경우 실행구문/ if / 조건식 / else / 거짓일 경우 실행구문
```

>실습  

`is_holiday`에 `True` 혹은 `False`값을 할당한 후 if문과 조건표현식을 사용해서 각각 'Good'과 'Bad를 출력하는 코드를 짜라'

```python
is_holiday=True
print('Good') if is_holiday else print('Bad')
Good

is_holiday=False
print('Good') if is_holiday else print('Bad')
Bad
```

+ 중첩 조건표현식

```
# 조건이 2개일 경우
조건1이 참일 경우 if 조건1 else 조건1은 거짓이나 조건2가 참일 경우 if 조건2 else 조건1,2가 모두 거짓일 경우
```

>실습

```
vacation에 1에서 10중 아무 값이나 할당 후, if, elif, else문과 중첩 조건표현식을 사용해서 각각 vacation이 7이상이면 'Good', 5이상이면 'Normal', 그 이하면 'Bad'를 출력하는 코드를 짜본다.
```

```python
vacation=3
print('Good') if vacation>=7 else print('Normal') if vacation>=5 else p rint('Bad')
Bad

vacation=6
Normal

vacation=8
Good
```

### for문 (조건에 따른 순회)

+ 기본형태

시퀀스형 데이터를 순회하고자 할 때 사용한다.

```
for 항목 in 순회가능(iterable)객체:
  <항목을 사용한 코드>
```

iterable한 객체에는 문자열, 튜플, 딕셔너리, 셋 등이 있다.

```Python
>>> champion_list = ['lux', 'ahri', 'ezreal', 'zed']
>>> for champion in champion_list:
...   print(champion)
...
lux
ahri
ezreal
zed
```

딕셔너리에서 키나 값을 순회할 때는, iterable한 객체의 위치에 dict.keys()나 dict.values()를 사용한다.
키, 값을 모두 순회할 때에는 dict.items()를 사용한다.

+ 중첩

```
for 항목1 in iterable객체1:
  iterable객체1을 순회하며 실행할 코드
  for 항목2 in iterable객체2:
    iterable객체1 내부에서 새로운 iterable객체2를 순회하며 실행할 코드
```

+ 중단하기(break)

데이터를 순회하던 중, 특정 조건에서 순회를 멈추고 반복문을 빠져나갈 때 사용한다.

```
for 항목 in iterable객체:
  (반복문을 중단하고 싶을 때)break
```

+ 건너뛰기continue)

데이터를 순회하던 중, 반복문을 중단하지 않고 다음 반복으로 건너뛸 때 사용한다.

```
for 항목 in iterable객체:
  (현재의 반복을 중간에 그만두고 다음 반복으로 건너뛰고 싶을 때)continue
```

+ break확인 (else)

for문으로 데이터를 순회하던 중, break문이 호출되지 않고 반복문이 종료되면 else문이 실행된다.

```
for 항목 in iterable객체:
  pass
else:
  break가 한 번도 호출되지 않았을 경우의 코드
```

+ 여러 시퀀스 동시순회 (zip)

```Python
>>> fruits = ['apple', 'banana', 'melon']
>>> colors = ['red', 'yellow', 'green', 'purple']
>>> for fruit, color in zip(fruits, colors):
...   print('fruit:', fruit, 'color:', color)
...
fruit: apple  color: red
fruit: banana  color: yellow
fruit: melon  color: green
```

zip으로 묶은 시퀀스들 중, 가장 짧은 시퀀스가 완료되면 순회가 종료된다.

zip을 사용하면 여러 시퀀스로부터 튜플을 만들 수 있다.

```
>>> list(zip(fruits, colors))
```

zip으로 반환되는 것은 리스트가 아닌 zip클래스 형태의 iterable객체이기 때문에, 리스트 형태로 사용하려면 list()함수를
사용해준다.

dict()함수를 사용할 경우 딕셔너리 개체가 만들어지게 된다.

>실습 - zip 없이 두 시퀀스 동시에 순회하기

```python
fruits = ['apple', 'banana', 'melon']
colors = ['red', 'yellow', 'green', 'purple']

index = 0

for fruit in fruits:
        print(fruit, colors[index])
        print('fruit(%s), color(%s)' % (fruit, colors[index]))
        index +=1


print(zip(fruits, colors)) - zip object
```

+ 숫자 시퀀스 생성(range)

range()함수는 특정 범위의 숫자 스트림 데이터를 반환한다.

range(0,10) - 0부터 10 미만까지

```
range(start, stop, step)
```

zip과 마찬가지로, iterable한 객체를 반환하며, 따라서 for문을 순회할 수 있다.

```python
>>> for x in range(0,10):
...   print(x)
...
0
1
2
3
4
5
6
7
8
9
```

### while문

for문과 유사하나, while뒤의 조건이 참일 경우에 계속해서 반복한다.

```
while 조건:
  조건이 참일경우 실행
  조건이 거짓이 될 경우까지 계속해서 반복
```

```Python
>>> count = 0
>>> while count < 10:
...   print(count)
...   count += 1
...
0
1
2
3
4
5
6
7
8
9
```

## 8. 컴프리헨션(Comprehension)

>함축 또는 내포

iterable한 객체로부터 파이썬의 자료구조를 만드는 방법. 가독성과 사용성에서 이득을 얻을 수 있을 경우 항상 사용해준다.

### 리스트 컴프리헨션

```
[표현식 for 항목 in iterable객체]
```

[1,2,3,4,5]를 만드는 방법

*range와 for문을 사용할 경우*

```Python
>>> numbers = []
>>> for item in range(1,6):
...   numbers.append(item)
...
>>> numbers
[1,2,3,4,5]
```

*리스트 컴프리헨션을 사용할 경우*

```python
>>> [item fo item in range(1,6)]
[1,2,3,4,5]
```

+ 리스트 컴프리헨션의 중첩

```
for color in colors:
  for fruit in fruits:
```

```
[(color, fruit) for color in colors for fruit in fruits]
```

> 실습 리스트 컴프리헨션 - 짝수 항목만 리스트화 하기

[item for item in range(1,6) if item%2 == 0]

[표현식 for 항목 in iterable객체 조건문]

### 셋 컴프리헨션

```
{표현식 for 표현식 in iterable객체}
```

실습
1. for문을 2개 중첩하여 0,0 -> 6,3까지 출력

```python
for item1 in range(0,7):
    for item2 in range(0,4):
        print('(%d, %d)' % (item1, item2))
```

2. 리스트 컴프리헨션으로 위 항목 생성


`['(%d, %d)' % (item1, item2) for item1 in range(0,7) for item2 in range(0,4)]`

문자열로 리스트

`l2 = [(x,y) for x in range(7) for y in range(4)]`

튜플로 리스트

3. 1, 2번의 반복문에서 1번은 튜플의 첫 번째 항목이 짝수일때만 출력하도록,

 2번은 첫 번째 항복이 짝수일때만 리스트의 원소로 추가

```python
for item1 in range(0,7):
    for item2 in range(0,4):
        if item1%2==0:
            print(item1,item2)

l= [(item1, item2) for item1 in range(0,7) for item2 in range(0,4) if item1%2==0]
```

 4. 1000에서 2000까지 숫자 중, 홀수의 합을 구해본다.

```python
result = 0
for i in range(1000, 2001):
    if i%2==1:
        result+=i

print(result)
```

#컴프리헨션과 내장함수 sum 이용

```python
result= sum([x for x in range(1000,2001) if x % 2 ==1])
print(result)
```

#sum - iterable 내의 값을 모두 더해주는 내장함수

#더 효율적인 방법으로 step 사용

```python
result = sum([x for x in range(1001,2000,2)])
print(result)
```

 5.

```python
gugu=[item1*item2 for item1 in range(2,10) for item2 in range(1,10)]
index = 0

for x in range(2,10):
    for y range(1,10):
        print('%d X %d = %d'(x,y,gugu[index]))
        index+=1

#기초적인 방법
l = ['%d x %d = %d' % (x, y, x*y) for x in range(2,10) for y in range(1,10)]


# 현재 출력중인 결과가 구구단 중 '몇'단에 해당하는지의 index
gugu_index = 2
# 전체 구구단 결과 리스트 중 몇 번째를 순회하고 있는지의 index
list_index = 0
for item in l:
    #전체 구구단 리스트의 아이템 중 9번째마다 실행
    if list_index % 9 ==0:
        print('== %s단 ==' % gugu_index)
        # 한 번 '몇'단인지 출혁 후에는 다음 단의 index를 저장
        gugu_index += 1
    # 전체 구구단 결과 리스트 중 몇 번째를 순회하는 중인지 업데이트
    list_index += 1
    # 전체 구구단 결과 중 현재 순회중인 item을 출력
    print(item)


# enumerate 내장함수 사용, index를 생략
for list_index, item in enumerate(l):
    if list_index % 9 ==0:
        print('== %단 ==' % gugu_index)
        gugu_index += 1
    print(item)

#dict를 사용해서 gugu_index를 구구단 자료구조내에 포함
#for 문으로 순회 시, 각 리스트의 항목이 dict가 되도록 한다.
# 각 dict는 자신이 '몇단'인지의 정보와 9개의 결과 리스트를 갖는다.
/*
gugu_iist =

for i in range(2,10):
    {'title':'%d단'(% i),'items':['%d x %d = %d' % (i,y,i*y) for y in range(1,10)] }
*/

# 정답

gugu_list = [ {'title':'%d단' % (x), 'items':['%d x %d = %d' % (x, y, x*y) for y in range(1,10)] } for x in range(2,10)]

print(gugu_list)


for gugu in gugu_list:
    print(gugu['title'])
    for item in gugu['items']:
        print(item)
    print('')
```

 6. 7의 배수이거나 9의 배수인 숫자의 리스트, 7의 배수이면서 9의 배수인 수는 한 번만 추가

```python
list79=sorted(list(set([result for x in range(1,99) if x%7==0 or x%9==0])))

result = []
for x in range(1,100):
    if x % 7 == 0 or x % 9 == 0:
        result.append(x)

print(result)
```

### 제네레이터 컴프리헨션

```
(표현식 for 표현식 in iterable객체)
```
괄호로 되어있지만 튜플을 생성하지 않는다. (튜플은 컴프리헨션이 없다.)

제네레이터 객체는 순회 가능하며, 리스트 형태로 만들 수 있다.

## 9. 함수

반복적인 작업을 하는 코드를 재사용이 가능하게 정의해 놓은 것.

```python
def 함수명(매개변수[parameters]):
  동작
```

### 함수의 정의, 실행

```python
# 실행 시 'call func'를 print하는 함수 정의
>>> def func():
...   print('call func')
...

# 함수 자체는 function객체를 참조하는 변수
>>> func
<function func at 0x10dabf378>

# 함수를 실행시키기 위해 () 사용
>>> func()
call func
```

### 리턴값이 있는 함수 정의

```Python
>>> def return_true():
...   return True
...
>>> return_true()
True
```

함수의 결과로 Bool 값을 갖는 데이터를 리턴하여 if문이나 while문의 조건으로 사용 가능하다.

### 매개변수를 사용하는 함수 정의

```Python
>>> def print_arguments(something):
...   print(something)
...
>>> print_arguments('ABC')
ABC
```

### 매개변수(parameter)와 인자(argument)의 차이

함수 내부에서 함수에게 전달되어 온 변수는 매개변수라 부르며, 함수를 호출할 때 전달하는 변수는 인자로 부른다.

```python
# 함수 정의때는 매개변수
def func(매개변수1, 매개변수2):
  ...

# 함수 호출시에는 인자
>>> func(인자1, 인자2)
```

### 리턴값이 없을 경우

함수에서 리턴해 주는 값이 없을 경우, 아무것도 없다는 뜻을 가진 'None' 객체를 얻는다.

### 위치 인자(Positional argument)

매개변수의 순서대로 인자를 전달하여 사용하는 경우

```python
>>> def student(name, age, gender):
...   return {'name': name, 'age': age, 'gender': gender}
...
>>> student('hanyeong.lee', 30, 'male')
{'name': 'hanyeong.lee', 'age': 30, 'gender': 'male'}
```

### 키워드 인자(Keyword argument)

매개변수의 이름을 지정하여 인자로 전달하여 사용하는 경우

```python
>>> student(age=30, name='hanyeong.lee', gender='male')
{'name': 'hanyeong.lee', 'age': 30, 'gender': 'male'}
```

**위치인자와 키워드인자를 동시에 쓴다면, 위치인자가 먼저 와야 한다.**

함수 호출시의 이야기...

### 기본 매개변수값 지정

인자가 제공되지 않을 경우, 기본 매개변수로 사용할 값을 지정할 수 있다.
인자를 제공하면 무시된다.

```python
>>> def student(name, age, gender, cls='WPS'):
...   return ('name': name, 'age': age, 'gender': gneder, 'class': cls)
...
>>> student('hanyeong lee', 30, 'male')
{'name': 'hanyeong lee', 'age': 30, 'gender': 'male', 'class': 'WPS'}
```

### 기본 매개변수값의 정의 시점

> 기본 매개변수값은 함수가 실행될 때 마다 계산되지 않고, 함수가 정의되는 시점에 계산되어 계속해서 사용된다.


```python
>>> def return_list(value, result=[]):
...   result.append(value)
...   return result
...
>>> return_list('apple')
['apple']
>>> return_list('banana')
['apple', 'banana']
```
현재 **result** 가 한번만 계산되고(id가 일치) 계속 쓰이고 있음을 알 수 있다. 그래서 append 메소드가 연속된다.


함수가 실행되는 시점에 기본 매개변수값을 계산하기 위해, 아래와 같이 바꿔준다.

```python
>>> def return_list(value, result=None):
...   if result is None:
...     result = []
...   result.append(value)
...   return result
...
>>> return_list('apple')
['apple']
>>> return_list('banana')
[banana]
```

### 위치인자 묶음

함수에 위치인자로 주어진 변수들의 묶음은 `*매개변수명`으로 사용할 수 있다.  
관용적으로 `*args`를 사용한다.

```python
def print_args(*args):
  print(args)
```
몇 개든 다 받을 수 있다.

### 키워드인자 묶음

함수에 키워드인자로 주어진 변수들의 묶음은 `**매개변수명`으로 사용할 수 있다.
관용적으로 `**kwargs`를 사용한다.

```python
def print_kwargs(**kwargs):
  print(kwargs)
```

```python
def print_all_args(*args, **kwargs):
  print(args)
  print(kwargs)
```

>실습

```python
def practice(*args):
  if enumerate(*args) ==2:
    return *args[0] * *args[1]
  elif enumerate(*args) ==1:
    return *args**2
  else
    print('다시 입력하세요')

#정답

def mul(*args):
  if len(args) ==1:
    return args[0] ** 2
  elif len(args) ==2:
    return args[0] * args[1]

```

### docstring

함수를 정의한 문서 역할을 한다.
함수 정의 후, 몸체의 시작부분에 문자열로 작성하며, 여러줄로도 작성 가능하다.

```python
>>> def print_args(*args):
...   'Print positional arguments'
...   print(args)
...
>>> help(print_args)
```

### 함수를 인자로 전달

파이썬에서는 함수 역시 다른 객체와 동등하게 취급되므로, 함수에서 인자로 함수를 전달, 실행, 리턴하는 형태로 프로그래밍이 가능하다.

>실습

- 'call func'를 출력하는 함수를 정의하고, 함수를 인자로 받아 실행하는 함수를 정의하여 첫 번째에 정의한 함수를 인자로 전달해 실행해보자.

```python

def args_func(func):
  func()

def print_call_func():
  print(call func)

print(print_call_func)
print(print_call_func())


```

### 내부 함수

함수 안에서 또 다른 함수를 정의해 사용할 수 있다.


>실습

- 문자열 인자를 하나 전달받는 함수를 만들고, 해당 함수 내부에 전달받은 문자열을 대문자화해서 리턴해주는 내부 함수를 구현한다.  
문자열을 전달받는 함수는 내부함수를 실행한 결과를 리턴하도록 한다.

```python
def string_func('x'):
  def string_cap_func('x'):
    return upper('x')
  print(string_cap_func())
```


### 스코프(영역)

파이썬에서는 코드 작성 시, 각 함수마다 독립적인 스코프(영역)을 가진다.  
메인 프로그램(현재 동작하는 프로그램의 최상위 위치)의 영역은 전역 영역(Global Scope)라고 하며, 전역 스코프 내부에서 독립적인 영역을 갖고 있는 경우에는 지역 영역(Local Scope)라고 부른다.

아래 코드의 경우, `show_global_champion`함수 내부의 영역은 별개의 로컬 스코프를 가지며, `champion`변수는 전역 영역의 것을 가져와 출력하는것을 볼 수 있다.

```python
champion = 'Lux'

def show_global_champion():
    print('show_global_champion : {}'.format(champion))
    print(f'show_global_champion: {champion}')
show_global_champion()
print('print champion : {}'.format(champion))
```

위 코드를 아래와 같이 변경 후, 실행 해 본다.

```python
champion = 'Lux'

def show_global_champion():
    print('show_global_champion : {}'.format(champion))

def change_global_champion():
    print('before change_global_champion : {}'.format(champion))
    champion = 'Ahri'
    print('after change_global_champion : {}'.format(champion))

show_global_champion()
change_global_champion()

```

`change_global_champion`함수에서 오류가 발생한다.

두 번째 함수는 첫 번째 줄부터 오류. 1. 두 번째 함수는 로컬 영역에 해당 변수가 존재하지만, 할당 전에 호출하기 때문에 오류가 나는 것이다. 로컬 스코프 내의 변수가 어디든 정의되어 있다면 그 변수만을 참조한다. 3. 스코프 내에 같은 이름의 변수가 없다면 스코프 외부의 변수를 찾는다.

첫 번째 코드에서는 `champion`변수가 함수의 로컬 스코프에 존재하지 않기 때문에 글로블 스코프에서 해당 변수를 찾아 출력하였으나, 이번 코드에서는 내부에 또다른 `champion`변수가 존재하기 때문에 할당하기 전인 변수를 사용한 것으로 판단하여 프로그램에서 오류를 발생시킨다.


```python
def show_global_champion():
    print('g_id:' id(champion))
    print('show_global_champion : {}'.format(champion))

def change_global_champion():
#    print('before change_global_champion : {}'.format(champion))
    champion = 'Ahri'
    print('c_id:' id(champion))
    print('after change_global_champion : {}'.format(champion))
```

이름이 같은 두 변수가 다른 객체임을 내장함수 `id`를 사용해 확인해보자.

아이디가 다르다는 것을 알 수 있다.

또한, 각 영역에 현재 스코프에 해당하는 데이터들은 `locals()`함수를 사용해 확인 할 수 있으며, 전역 영역의 데이터들은 `globals()`함수를 사용한다.

### 스코핑 룰

스코프는 지역(Local), 전역(Global)외에도 내장(Built-in)영역이 존재하며, 내장영역이 가장 바깥, 그 내부에 전역, 그 내부에 지역 순으로 정의된다.   - 내장함수들이 들어 있는 곳
분리된 영역에서, 외부 영역에서는 내부 영역의 데이터를 사용할 수 없지만 내부 영역에서는 자신의 외부 영역에 있는 데이터를 참조할 수 있다.  
(반대의 경우에는 함수의 인자로 데이터를 전달한다)

### 내장 함수와 내장 영역

`print`, `dict`등 지정하지 않고 사용했던 내장 함수들은 위 스코핑 룰의 내장 스코프에 존재하는 함수들이다.  
전역스코프의 `__builtin__`변수에 할당되어 있으며, 전역 스코프에서는 해당 변수의 내부를 참조할 수 있도록 파이썬이 시작될 때 자동으로 처리된다.

확인시 `dir`함수를 사용하며, `dir`함수는 해당 객체가 사용 가능한 속성 및 함수들을 리스트 형태로 나타내준다.

### 로컬 스코프에서 글로벌 스코프의 변수를 사용

```python
champion = 'Lux'

def change_global_champion():
    champion = 'Ahri'
    print('after change_global_champion : {}'.format(champion))

change_global_champion()
print('print global champion : {}'.format(champion))
```

이 경우, 위의 `show_global_champion`함수와는 다르게 `change_global_champion`함수는 `champion`변수에 새로운 값을 대입한다.  
만약 로컬 스코프에서 글로벌 스코프의 변수를 변경해야 한다면, 해당 변수가 로컬 스코프에 생성되는 것이 아닌 글로벌 영역에 이미 존재하는 값을 사용함을 명시해주어야 한다.

```python
champion = 'Lux'

def change_global_champion():
    global champion
    champion = 'Ahri'
    print('after change_global_champion : {}'.format(champion))
# 전역변수를 참조하여 변경한 것이므로 전역의 champion변수도 Ahri로 변경된다.



change_global_champion()
print('print global champion : {}'.format(champion))
```

> 실습

```python
champion='Lux'

def change_global_champion():
  global champion
  print(id(champion))
  champion = 'Ahri'
  print('after change_global_champion : {}'.format(champion))
  print(id(champion))

```


파이썬에서는 한 스코프에서 동일한 이름을 가진 두 스코프의 변수를 사용할 수 없음을 기억해야 한다.

### 내부함수에서의 로컬 스코프 (nonlocal)

```python
champion = 'Lux'

def local1():
    champion = 'Ahri'
    print('local1 locals() : {}'.format(locals()))

    def local2():
        champion = 'Ezreal'
        print('local2 locals() : {}'.format(locals()))
    local2()

print('global locals() : {}'.format(locals()))
local1()
```

로컬 스코프 내부에는 또 다른 로컬 스코프가 존재할 수 있다.  
로컬에서 해당 변수가 없어 외부에서 참조하려고 한다면 한 스코프씩 올라가게 된다.
전역 스코프가 아닌, 자신의 바로 바깥 영역의 로컬 스코프(자신보다 한 단계 위의 로컬 스코프)의 데이터를 참조하고자 한다면, `nonlocal`키워드를 사용한다.

```python
champion = 'Lux'

def local1():
    champion = 'Ahri'
    print('local1 locals() : {}'.format(locals()))

    def local2():
        nonlocal champion
        champion = 'Ezreal'
        print('local2 locals() : {}'.format(locals()))
    local2()
    print('local1 locals() : {}'.format(locals()))

print('global locals() : {}'.format(locals()))
local1()
```


#### global키워드와 인자(argument)전달의 차이

인자로 전달한 경우

```python
global_level = 100
def level_add(value):
    value += 30
    print(value)

level_add(global_level)
print(global_level)
```

global키워드를 사용한 경우

```python
global_level = 100
def level_add():
    global global_level
    global_level += 30
    print(global_level)

level_add()
print(global_level)
```

인자로 전달한 경우, 같은 객체를 가리키는 글로벌 변수 `global_level`과 매개변수 `value`가 존재한다.  
이 때, 매개변수인 `value`의 값을 변경하는 것은 `global_level`에는 영향을 주지 않는다.

global키워드의 경우 둘은 같은 변수이다.

하지만 리스트 변수가 전달된다면?

#### 람다함수

한 줄 짜리 표현식으로 이루어지며, 반복문이나 조건문 등의 제어문은 포함될 수 없다.  
또한, 함수이지만 정의/호출이 나누어져 있지 않으며 표현식 자체가 바로 호출된다.

```python
lambda <매개변수> : <표현식>
```

```
# 함수의 정의
>>> def multi(x):
...   return x*x
...

# 함수의 호출
>>> multi(5)
25

# 람다함수의 사용
>>> (lambda x : x*x)(5)
25

# 람다함수를 사용해 함수 정의
>>> f = lambda x : x*x
>>> f(5)
25
```

#### 람다함수의 사용

```python
import string
>>> for char in string.ascii_lowercase:
...   if char > 'i':
...     print(char.upper())
...   else:
...     print(char)
```

```
>>> for char in string.ascii_lowercase:
...   print((lambda x : x.upper() if x > 'i' else x)(char))
```

#### 클로져 (Closure)

함수가 정의된 환경을 말하며, 파이썬 파일이 여러개일 경우 각 파일은 하나의 `모듈`역할을 하고, 각 `모듈`은 독립적인 환경을 가진다.  
독립된 환경은 각자의 영역을 전역 영역으로 사용한다.

**closure/module_a.py**

```python
level = 100
def print_level():
    print(level)
```

**closure/module_b.py**

```python
import module_a
level = 50
def print_level():
    print(level)

module_a.print_level()
print_level()
```

`python module_b.py`로 `module_b`를 실행한다.

함수의 전역 영역은 해당 함수가 정의된 모듈의 전역 영역으로, 전역변수는 모듈의 영역에 영향을 받는다.

#### 내부함수의 클로져

```python
>>> level = 0
>>> def outter():
...   level = 50
...   def inner():
...     nonlocal level
...     level += 3
...     print(level)
...   return inner
...
>>> func = outter()
```

위의 경우, `outter`함수는 `inner`함수를 반환하여 결과를 `func`전역변수에 할당한다.  
`inner`함수의 호출 결과가 아닌 함수 자체를 반환하기 때문에, `func`변수는 실행할 수 있는 함수객체이다.  
이 때 `inner`함수가 사용하는 `level`변수는 `nonlocal`키워드를 사용했기 때문에 `outter`에 새로 정의된 지역변수 `level`을 사용한다.  
반복적으로 `func`함수를 실행하면 `inner`의 외부(`outter`)에 존재하는 `level`변수의 값을 증가시키고 `print`시키기 때문에, 값은 계속해서 증가한다.

func2를 만든다면?
